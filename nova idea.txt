# Sistema de Blocos para Processamento em Cadeia

## Descrição
Este código implementa um sistema escalável baseado no padrão **Chain of Responsibility**, ideal para cenários complexos onde diferentes blocos de processamento precisam atuar sobre um dado sem modificar a estrutura principal do código. 

Cada bloco de código (função ou classe) avalia se pode processar os dados recebidos. Caso não possa, ele encaminha automaticamente a solicitação para o próximo bloco da cadeia, garantindo que o processamento continue até encontrar um bloco adequado ou esgotar as opções disponíveis. 

Essa abordagem permite adicionar novos blocos de processamento sem necessidade de alterar os existentes, garantindo modularidade e facilitando a manutenção do código sem a necessidade de dividir arquivos ou seguir padrões como SOLID.



oi hj vc vai me ajudar a refatorar um codigo e garantir que ele continue funcionaod perfeitamente, qual o motivo disso° quero escalar ele, de uma foram que todos os blocos que vc criar devem ter um pass caso ele nao seja necessario na implmentação do meu compilador, atualmente ele tem 3 arquivos lexer, parser e generator , iriei mandar aqui pra vc e vc vai criar um chians of responsability pra cada um desses arquivos, exemplo genrator)chain, parser_chain enfim, de uma foram que nova implementações irao apenas adiconar novos blocos dentro do chain, crie tbm parametros de cada bloco para identificação para que vc posso evitar de entrar em certos blocos caso haja ambiguidade, os arquivos sao: def lexer(code):
    tokens = []
    keywords = {
        'module', 'endmodule', 'input', 'output', 'inout', 'wire', 'reg',
        'always', 'begin', 'end', 'if', 'else', 'assign', 'posedge', 'negedge', 'or',
        '$monitor', '$time', '$finish', 'initial'  # Adicionado 'initial'
    }
    operators = {
        '+', '-', '*', '/', '%', '==', '!=', '<', '>', '<=', '>=', '&&', '||',
        '!', '&', '|', '^', '~', '<<', '>>', '=', ':', '#' 
    }
    
    print("Iniciando lexer...")
    i = 0
    while i < len(code):
        char = code[i]

        if char.isspace():
            i += 1
            continue

        if char == '/' and i + 1 < len(code):
            if code[i + 1] == '/':
                while i < len(code) and code[i] != '\n':
                    i += 1
                continue
            elif code[i + 1] == '*':
                i += 2
                while i < len(code) and not (code[i - 1] == '*' and code[i] == '/'):
                    i += 1
                i += 1
                continue

        if char == '"':  # Tratamento de strings
            i += 1
            string = ''
            while i < len(code) and code[i] != '"':
                string += code[i]
                i += 1
            i += 1  # Pula o '"'
            token = ('STRING', string)
            tokens.append(token)
            print(f"Token adicionado: {token}")
            continue

        if char.isalpha() or char == '_' or char == '$':
            word = ''
            while i < len(code) and (code[i].isalnum() or code[i] in '_$'):
                word += code[i]
                i += 1
            token = ('KEYWORD', word) if word in keywords else ('IDENTIFIER', word)
            tokens.append(token)
            print(f"Token adicionado: {token}")
            continue

        if char.isdigit() or (char == "'" and i > 0 and code[i - 1].isdigit()):
            num = char
            i += 1
            while i < len(code) and (code[i].isdigit() or code[i] in "'bhdx"):
                num += code[i]
                i += 1
            token = ('NUMBER', num)
            tokens.append(token)
            print(f"Token adicionado: {token}")
            continue

        op = char
        if i + 1 < len(code) and char + code[i + 1] in operators:
            op = char + code[i + 1]
            i += 2
        elif char in operators:
            i += 1
        if op in operators:
            token = ('OPERATOR', op)
            tokens.append(token)
            print(f"Token adicionado: {token}")
            continue

        if char in '();,[]{}@':
            token = ('SYMBOL', char)
            tokens.append(token)
            print(f"Token adicionado: {token}")
            i += 1
            continue

        token = ('UNKNOWN', char)
        tokens.append(token)
        print(f"Token desconhecido: {token}")
        i += 1

    print("Lexer concluído. Tokens gerados:", tokens)
    return tokens,,,,,, class Parser:
    def __init__(self, tokens):
        self.tokens = tokens
        self.pos = 0
        print("Iniciando parser com tokens:", tokens)

    def current_token(self):
        token = self.tokens[self.pos] if self.pos < len(self.tokens) else (None, None)
        print(f"Token atual (pos {self.pos}): {token}")
        return token

    def consume(self, expected_type=None, expected_value=None):
        token_type, token_value = self.current_token()
        if (expected_type and token_type != expected_type) or (expected_value and token_value != expected_value):
            raise ValueError(f"Esperado {expected_type} {expected_value}, encontrado {token_type} {token_value}")
        self.pos += 1
        print(f"Consumido: ({token_type}, {token_value})")
        return token_type, token_value

    def parse(self):
        ast = {'type': 'Program', 'body': []}
        print("Parsing programa...")
        while self.pos < len(self.tokens):
            token_type, token_value = self.current_token()
            if token_type == 'KEYWORD' and token_value == 'module':
                ast['body'].append(self.parse_module())
            else:
                self.pos += 1
        print("AST gerado:", ast)
        return ast

    def parse_module(self):
        print("Parsing module...")
        self.consume('KEYWORD', 'module')
        _, module_name = self.consume('IDENTIFIER')
        
        ports = []
        if self.current_token()[1] == '(':  # Portas são opcionais
            self.consume('SYMBOL', '(')
            while self.current_token()[1] != ')':
                ports.append(self.parse_port())
                if self.current_token()[1] == ',':
                    self.consume('SYMBOL', ',')
                elif self.current_token()[1] != ')':
                    raise ValueError(f"Esperado ',' ou ')', encontrado {self.current_token()[1]}")
            self.consume('SYMBOL', ')')
        
        self.consume('SYMBOL', ';')

        body = []
        while self.pos < len(self.tokens) and self.current_token()[1] != 'endmodule':
            token_type, token_value = self.current_token()
            if token_value in ('input', 'output', 'inout', 'wire', 'reg'):
                body.append(self.parse_declaration())
            elif token_value == 'assign':
                body.append(self.parse_assign())
            elif token_value == 'always':
                body.append(self.parse_always())
            elif token_value == 'initial':
                body.append(self.parse_initial())
            else:
                print(f"Ignorando token no corpo do módulo: {token_type} {token_value}")
                self.pos += 1
        self.consume('KEYWORD', 'endmodule')
        return {'type': 'Module', 'name': module_name, 'ports': ports, 'body': body}

    def parse_bit_width(self):
        if self.current_token()[1] != '[':
            return None
        self.consume('SYMBOL', '[')
        
        high = 0
        if self.current_token()[0] == 'NUMBER':
            _, high = self.consume('NUMBER')
        
        self.consume('OPERATOR', ':')
        
        low = 0
        if self.current_token()[0] == 'NUMBER':
            _, low = self.consume('NUMBER')
        
        self.consume('SYMBOL', ']')
        return (int(high), int(low))

    def parse_port(self):
        print("Parsing port...")
        port_type = self.current_token()[1]
        if port_type not in ('input', 'output', 'inout'):
            raise ValueError(f"Tipo de porta inválido: {port_type}")
        self.consume('KEYWORD')

        data_type = None
        if self.current_token()[1] == 'logic':
            data_type = self.current_token()[1]
            self.consume('IDENTIFIER')

        bit_width = self.parse_bit_width() if self.current_token()[1] == '[' else None

        _, port_name = self.consume('IDENTIFIER')
        
        return {
            'type': port_type,
            'name': port_name,
            'data_type': data_type,
            'bit_width': bit_width
        }

    def parse_declaration(self):
        print("Parsing declaration...")
        decl_type = self.current_token()[1]
        self.consume('KEYWORD')

        bit_width = None
        if self.current_token()[1] == '[':
            bit_width = self.parse_bit_width()

        _, name = self.consume('IDENTIFIER')
        
        initial_value = None
        if self.current_token()[1] == '=':
            self.consume('OPERATOR', '=')
            _, initial_value = self.consume('NUMBER')
            initial_value = int(initial_value)
        
        self.consume('SYMBOL', ';')
        return {
            'type': 'Declaration', 
            'decl_type': decl_type, 
            'name': name, 
            'bit_width': bit_width, 
            'initial_value': initial_value
        }

    def parse_assign(self):
        print("Parsing assign...")
        self.consume('KEYWORD', 'assign')
        _, lhs = self.consume('IDENTIFIER')
        self.consume('OPERATOR', '=')
        rhs = self.parse_expression()
        self.consume('SYMBOL', ';')
        return {'type': 'Assign', 'lhs': lhs, 'rhs': rhs}

    def parse_always(self):
        print("Parsing always...")
        self.consume('KEYWORD', 'always')
        
        delay = None
        sensitivity_list = []
        token_type, token_value = self.current_token()
        
        if token_value == '#':
            self.consume('OPERATOR', '#')
            _, delay_value = self.consume('NUMBER')
            delay = int(delay_value)
            
            _, lhs = self.consume('IDENTIFIER')
            self.consume('OPERATOR', '=') 
            rhs = self.parse_expression()
            self.consume('SYMBOL', ';')
            
            return {'type': 'AlwaysDelay', 'delay': delay, 'statement': {'type': 'Assignment', 'lhs': lhs, 'rhs': rhs}}
        
        elif token_value == '@':
            self.consume('SYMBOL', '@')
            
            has_paren = self.current_token()[1] == '('
            if has_paren:
                self.consume('SYMBOL', '(')
            
            while True:
                edge = None
                if self.current_token()[1] in ('posedge', 'negedge'):
                    edge = self.current_token()[1]
                    self.consume('KEYWORD')
                
                _, signal = self.consume('IDENTIFIER')
                sensitivity_list.append({'edge': edge, 'signal': signal})
                
                next_token = self.current_token()
                if has_paren and next_token[1] == ')':
                    break
                elif not has_paren and next_token[1] == 'begin':
                    break
                elif next_token[1] in (',', 'or'):
                    self.consume()
                else:
                    raise ValueError(f"Esperado ',', 'or' ou ')', encontrado {next_token[1]}")
            
            if has_paren:
                self.consume('SYMBOL', ')')
            
            self.consume('KEYWORD', 'begin')
            
            statements = []
            while self.current_token()[1] != 'end':
                statements.append(self.parse_statement())
            
            self.consume('KEYWORD', 'end')
            return {'type': 'Always', 'sensitivity_list': sensitivity_list, 'statements': statements}
        
        else:
            raise ValueError(f"Esperado '@' ou '#', encontrado {token_value}")

    def parse_initial(self):
        print("Parsing initial...")
        self.consume('KEYWORD', 'initial')
        self.consume('KEYWORD', 'begin')
        
        statements = []
        while self.current_token()[1] != 'end':
            token_type, token_value = self.current_token()
            if token_value == '$monitor':
                statements.append(self.parse_monitor())
            elif token_value == '#':
                statements.append(self.parse_delay())
            else:
                statements.append(self.parse_statement())
        
        self.consume('KEYWORD', 'end')
        return {'type': 'Initial', 'statements': statements}

    def parse_monitor(self):
        print("Parsing $monitor...")
        self.consume('KEYWORD', '$monitor')
        self.consume('SYMBOL', '(')
        
        args = []
        while self.current_token()[1] != ')':
            if self.current_token()[0] == 'STRING':
                _, string = self.consume('STRING')
                args.append({'type': 'String', 'value': string})
            else:
                args.append({'type': 'Expression', 'value': self.parse_expression()})
            if self.current_token()[1] == ',':
                self.consume('SYMBOL', ',')
        
        self.consume('SYMBOL', ')')
        self.consume('SYMBOL', ';')
        return {'type': 'Monitor', 'args': args}

    def parse_delay(self):
        print("Parsing delay...")
        self.consume('OPERATOR', '#')
        _, delay_value = self.consume('NUMBER')
        
        if self.current_token()[1] == '$finish':
            self.consume('KEYWORD', '$finish')
            self.consume('SYMBOL', ';')
            return {'type': 'Finish', 'delay': int(delay_value)}
        else:
            _, lhs = self.consume('IDENTIFIER')
            self.consume('OPERATOR', '=')  # Suporta '='
            rhs = self.parse_expression()
            self.consume('SYMBOL', ';')
            return {'type': 'DelayAssignment', 'delay': int(delay_value), 'lhs': lhs, 'rhs': rhs}

    def parse_statement(self):
        print("Parsing statement...")
        token_type, token_value = self.current_token()
        if token_value == 'if':
            return self.parse_if()
        else:
            _, lhs = self.consume('IDENTIFIER')
            op_type, op_value = self.consume('OPERATOR')
            if op_value not in ('=', '<='):
                raise ValueError(f"Esperado '=' ou '<=', encontrado {op_value}")
            rhs = self.parse_expression()
            self.consume('SYMBOL', ';')
            return {'type': 'Assignment', 'lhs': lhs, 'rhs': rhs, 'operator': op_value}

    def parse_if(self):
        print("Parsing if...")
        self.consume('KEYWORD', 'if')
        self.consume('SYMBOL', '(')
        condition = self.parse_expression()
        self.consume('SYMBOL', ')')
        
        true_statements = []
        if self.current_token()[1] == 'begin':
            self.consume('KEYWORD', 'begin')
            while self.current_token()[1] != 'end':
                true_statements.append(self.parse_statement())
            self.consume('KEYWORD', 'end')
        else:
            true_statements.append(self.parse_statement())
        
        false_statements = []
        if self.current_token()[1] == 'else':
            self.consume('KEYWORD', 'else')
            if self.current_token()[1] == 'begin':
                self.consume('KEYWORD', 'begin')
                while self.current_token()[1] != 'end':
                    false_statements.append(self.parse_statement())
                self.consume('KEYWORD', 'end')
            else:
                false_statements.append(self.parse_statement())
        
        return {'type': 'If', 'condition': condition, 'true_statements': true_statements, 'false_statements': false_statements}

    def parse_expression(self):
        print("Parsing expression...")
        expr = []
        while self.current_token()[1] not in (';', ')', 'begin', 'end'):
            token_type, token_value = self.current_token()
            print(f"Analisando token na expressão: ({token_type}, {token_value})")
            
            if token_type == 'SYMBOL' and token_value == '{':  # Início de concatenação
                print("Detectado início de concatenação '{'")
                expr.append(('OPERATOR', 'CONCAT_START'))
                self.consume('SYMBOL', '{')
                concat_elements = []
                
                while self.current_token()[1] != '}':
                    print(f"Parsing elemento dentro de {{}}: {self.current_token()}")
                    if self.current_token()[0] in ('IDENTIFIER', 'NUMBER'):
                        concat_elements.append(self.parse_simple_expression())
                    else:
                        raise ValueError(f"Esperado identificador ou número em concatenação, encontrado {self.current_token()}")
                    
                    if self.current_token()[1] == ',':
                        self.consume('SYMBOL', ',')
                        print("Vírgula consumida em concatenação")
                    elif self.current_token()[1] != '}':
                        raise ValueError(f"Esperado ',' ou '}}', encontrado {self.current_token()[1]}")
                
                self.consume('SYMBOL', '}')
                print("Detectado fim de concatenação '}'")
                expr.append(('CONCAT', concat_elements))
                expr.append(('OPERATOR', 'CONCAT_END'))
            
            elif token_type in ('IDENTIFIER', 'NUMBER', 'STRING'):
                expr.append((token_type, token_value))
                self.consume()
            elif token_type == 'OPERATOR':
                expr.append((token_type, token_value))
                self.consume()
            elif token_value == '(':
                expr.append(('SYMBOL', '('))
                self.consume()
                expr.extend(self.parse_expression())
                self.consume('SYMBOL', ')')
                expr.append(('SYMBOL', ')'))
            else:
                self.consume()  # Avança em caso de tokens desconhecidos
            
            print(f"Estado atual da expressão: {expr}")
        
        print(f"Expressão parseada: {expr}")
        return expr

    def parse_simple_expression(self):
        """Helper para parsear expressões simples dentro de concatenações"""
        token_type, token_value = self.current_token()
        print(f"Parsing expressão simples: ({token_type}, {token_value})")
        if token_type in ('IDENTIFIER', 'NUMBER'):
            self.consume()
            return (token_type, token_value)
        raise ValueError(f"Esperado IDENTIFIER ou NUMBER, encontrado {token_type} {token_value}")

def parse(tokens):
    parser = Parser(tokens)
    return parser.parse(),,,,, def generate_python(ast):
    print("Iniciando geração de código Python com AST:", ast)
    python_code = []
    python_code.append("class Signal:\n    def __init__(self, value=0, bit_width=None):\n        self.value = value\n        self.bit_width = bit_width\n        if bit_width:\n            self.max_value = (1 << (bit_width[0] - bit_width[1] + 1)) - 1\n        self.prev_value = value  # Para detectar bordas\n\n    def set_value(self, value):\n        if self.bit_width:\n            self.value = value & self.max_value\n        else:\n            self.value = value\n\n")

    for node in ast['body']:
        if node['type'] == 'Module':
            module_name = node['name']
            ports = node['ports']
            body = node['body']

            python_code.append(f"class {module_name}:")
            python_code.append("    def __init__(self):")
            print(f"Gerando __init__ para módulo {module_name}")

            for port in ports:
                port_name = port['name']
                bit_width = port.get('bit_width')
                data_type = port.get('data_type', '')
                comment = f"{port['type']}"
                if data_type:
                    comment += f", {data_type}"
                if bit_width:
                    comment += f", [{bit_width[0]}:{bit_width[1]}]"
                python_code.append(f"        self.{port_name} = Signal(bit_width={bit_width})  # {comment}")
                print(f"Adicionado porto: self.{port_name}")

            for stmt in body:
                if stmt['type'] == 'Declaration':
                    var_name = stmt['name']
                    bit_width = stmt.get('bit_width')
                    initial_value = stmt.get('initial_value')
                    value_str = f", value={initial_value}" if initial_value is not None else ""
                    python_code.append(f"        self.{var_name} = Signal(bit_width={bit_width}{value_str})  # {stmt['decl_type']}")
                    print(f"Adicionada declaração: self.{var_name}")

            python_code.append("        self.time = 0  # Simulação de $time")

            python_code.append("\n    def update_combinational(self):")
            combinational_found = False
            for stmt in body:
                if stmt['type'] == 'Assign':
                    lhs = stmt['lhs']
                    rhs = translate_expression(stmt['rhs'])
                    python_code.append(f"        self.{lhs}.set_value({rhs})")
                    print(f"Adicionada atribuição combinacional: self.{lhs}.set_value({rhs})")
                    combinational_found = True
            if not combinational_found:
                python_code.append("        pass")

            python_code.append("\n    def update_sequential(self):")
            sequential_found = False
            clock_delay = None
            for stmt in body:
                if stmt['type'] == 'AlwaysDelay':
                    clock_delay = stmt['delay']
                    python_code.append(f"        # Clock gerado com atraso de {stmt['delay']} unidades")
                    python_code.append(f"        # Simulação simplificada: alterna o sinal")
                    python_code.append(translate_statement(stmt['statement'], indent=2))
                    print(f"Adicionado AlwaysDelay com delay {stmt['delay']}")
                    sequential_found = True
                elif stmt['type'] == 'Always':
                    sensitivity_list = stmt['sensitivity_list']
                    statements = stmt['statements']
                    sensitivity_comment = "        # Sensível a " + ", ".join(
                        f"{s['edge']} de {s['signal']}" if s['edge'] else s['signal'] 
                        for s in sensitivity_list
                    )
                    python_code.append(sensitivity_comment)
                    python_code.append("        # Simulação simplificada: atualiza na borda")
                    conditions = []
                    for s in sensitivity_list:
                        if s['edge'] == 'posedge':
                            signal = s['signal']
                            conditions.append(f"self.{signal}.value and not self.{signal}.prev_value")
                    if conditions:
                        python_code.append(f"        if {' or '.join(conditions)}:  # Borda positiva")
                        for sub_stmt in statements:
                            python_code.append(translate_statement(sub_stmt, indent=3))
                        for s in sensitivity_list:
                            if s['edge'] == 'posedge':
                                signal = s['signal']
                                python_code.append(f"        self.{signal}.prev_value = self.{signal}.value")
                    else:
                        for sub_stmt in statements:
                            python_code.append(translate_statement(sub_stmt, indent=2))
                    print(f"Adicionado bloco always: {sensitivity_list}")
                    sequential_found = True
            if not sequential_found:
                python_code.append("        pass")

            has_initial = False
            total_delay = 0
            for stmt in body:
                if stmt['type'] == 'Initial':
                    python_code.append("\n    def run_initial(self):")
                    python_code.append("        # Simulação do bloco initial")
                    for sub_stmt in stmt['statements']:
                        if sub_stmt['type'] == 'Monitor':
                            format_string = sub_stmt['args'][0]['value']
                            # Adicionar %0d como especificador válido
                            specifiers = [part for part in format_string.split() if part in ('%t', '%b', '%d', '%0d')]
                            args = []
                            if len(sub_stmt['args']) > 1:
                                # Assumir que o primeiro especificador numérico é $time
                                if '%t' in format_string or '%0d' in format_string:
                                    args.append("self.time")
                                for arg in sub_stmt['args'][1]['value']:
                                    if arg[0] == 'IDENTIFIER':
                                        args.append(f"self.{arg[1]}.value")
                                    elif arg[0] == 'KEYWORD' and arg[1] == '$time':
                                        args.append("self.time")
                                    else:
                                        args.append(translate_expression([arg]))
                            new_format_string = format_string
                            for i, spec in enumerate(specifiers):
                                if i < len(args):
                                    if spec == '%t' or spec == '%0d':
                                        new_format_string = new_format_string.replace(spec, f'{{{args[i]}}}', 1)
                                    elif spec == '%b':
                                        new_format_string = new_format_string.replace('%b', f'{{{args[i]}:b}}', 1)
                                    elif spec == '%d':
                                        new_format_string = new_format_string.replace('%d', f'{{{args[i]}}}', 1)
                            python_code.append(f"        print(f\"{new_format_string}\")")
                        elif sub_stmt['type'] == 'DelayAssignment':
                            total_delay += sub_stmt['delay']
                            python_code.append(f"        if self.time == {total_delay}:")
                            python_code.append(f"            self.{sub_stmt['lhs']}.set_value({translate_expression(sub_stmt['rhs'])})")
                        elif sub_stmt['type'] == 'Finish':
                            total_delay += sub_stmt['delay']
                            python_code.append(f"        if self.time == {total_delay}:")
                            python_code.append("            return False  # $finish")
                    python_code.append("        return True")
                    has_initial = True
                    break

            python_code.append("\n    def run(self):")
            if has_initial:
                python_code.append("        while self.run_initial():")
                python_code.append("            self.update_combinational()")
                python_code.append("            self.update_sequential()")
                time_step = clock_delay if clock_delay is not None else 1
                python_code.append(f"            self.time += {time_step}  # Passo de tempo baseado no clock")
            else:
                python_code.append("        self.update_combinational()")
                python_code.append("        self.update_sequential()")

            python_code.append("\n# Teste manual")
            python_code.append("if __name__ == \"__main__\":")
            python_code.append(f"    sim = {module_name}()")
            python_code.append("    sim.run()")

    result = "\n".join(python_code)
    print("Código Python gerado:", result)
    return result

def translate_expression(expr):
    print(f"Traduzindo expressão: {expr}")
    result = []
    i = 0
    while i < len(expr):
        token_type, token_value = expr[i]
        
        if token_type == 'OPERATOR' and token_value == '~':
            i += 1
            if i < len(expr) and expr[i][0] == 'IDENTIFIER':
                result.append(f"1 - self.{expr[i][1]}.value")
                i += 1
            else:
                result.append('~')
        elif token_type == 'IDENTIFIER':
            result.append(f"self.{token_value}.value")
            i += 1
        elif token_type == 'NUMBER':
            if "'b" in token_value:
                bits, value = token_value.split("'b")
                result.append(str(int(value, 2)))
            elif "'h" in token_value:
                bits, value = token_value.split("'h")
                result.append(str(int(value, 16)))
            else:
                result.append(token_value)
            i += 1
        elif token_type == 'OPERATOR':
            if token_value == '&&':
                result.append('and')
            elif token_value == '||':
                result.append('or')
            elif token_value == '!':
                result.append('not ')
            elif token_value == 'CONCAT_START':
                i += 1
                if i < len(expr) and expr[i][0] == 'CONCAT':
                    concat_terms = expr[i][1]
                    translated_terms = []
                    for term in concat_terms:
                        if term[0] == 'IDENTIFIER':
                            translated_terms.append(f"self.{term[1]}.value")
                        else:
                            translated_terms.append(translate_expression([term]))
                    i += 1
                    i += 1
                    concat_expr = []
                    for idx, term in enumerate(reversed(translated_terms)):
                        concat_expr.append(f"({term} << {idx})")
                    result.append(" | ".join(concat_expr))
                else:
                    result.append("CONCAT_START")
            else:
                result.append(token_value)
            i += 1
        elif token_type == 'SYMBOL' and token_value == '{':
            concat_terms = []
            i += 1
            while i < len(expr) and expr[i][1] != '}':
                if expr[i][0] == 'IDENTIFIER':
                    concat_terms.append(f"self.{expr[i][1]}.value")
                elif expr[i][0] == 'SYMBOL' and expr[i][1] == ',':
                    i += 1
                    continue
                else:
                    concat_terms.append(translate_expression([expr[i]]))
                i += 1
            i += 1
            concat_expr = []
            for idx, term in enumerate(reversed(concat_terms)):
                concat_expr.append(f"({term} << {idx})")
            result.append(" | ".join(concat_expr))
        elif token_type == 'SYMBOL':
            result.append(token_value)
            i += 1
        elif token_type == 'STRING':
            result.append(f"'{token_value}'")
            i += 1
        elif token_type == 'KEYWORD' and token_value == '$time':
            result.append("self.time")
            i += 1
        else:
            i += 1
    
    translated = ' '.join(result)
    print(f"Expressão traduzida: {translated}")
    return translated

def translate_statement(stmt, indent=0):
    print(f"Traduzindo statement: {stmt}")
    indent_str = "    " * indent
    if stmt['type'] == 'Assignment':
        lhs = stmt['lhs']
        rhs = translate_expression(stmt['rhs'])
        return f"{indent_str}self.{lhs}.set_value({rhs})"
    elif stmt['type'] == 'If':
        condition = translate_expression(stmt['condition'])
        true_code = [translate_statement(s, indent + 1) for s in stmt['true_statements']]
        false_statements = stmt.get('false_statements', [])
        code = [f"{indent_str}if {condition}:"]
        code.extend(true_code)
        if false_statements:
            if len(false_statements) == 1 and false_statements[0]['type'] == 'If':
                # Transforma o próximo If em elif
                next_if = false_statements[0]
                next_condition = translate_expression(next_if['condition'])
                next_true_code = [translate_statement(s, indent + 1) for s in next_if['true_statements']]
                next_false_statements = next_if.get('false_statements', [])
                code.append(f"{indent_str}elif {next_condition}:")
                code.extend(next_true_code)
                if next_false_statements:
                    code.append(f"{indent_str}else:")
                    code.extend([translate_statement(s, indent + 1) for s in next_false_statements])
            else:
                code.append(f"{indent_str}else:")
                code.extend([translate_statement(s, indent + 1) for s in false_statements])
        return "\n".join(code)
    return f"{indent_str}pass  # Declaração não suportada: {stmt['type']}" a view qe faz as requisições eh: # api/views.py

from rest_framework.decorators import api_view
from rest_framework.response import Response
from rest_framework import status
from .compilerSysLogPy.lexer import lexer as syslog_lexer
from .compilerSysLogPy.parser import parse as syslog_parse
from .compilerSysLogPy.generator import generate_python

@api_view(['POST'])
def compiler_syslog_py(request):
    try:
        code = request.data.get('code', '')
        if not code:
            return Response({'error': 'Nenhum código fornecido.'}, status=status.HTTP_400_BAD_REQUEST)

        # Tokenização
        tokens = syslog_lexer(code)

        # Parsing
        ast = syslog_parse(tokens)

        # Geração de Python
        py_code = generate_python(ast)
        
        print(py_code)

        return Response({
            'tokens': tokens,
            'ast': str(ast),
            'python': py_code
        }, status=status.HTTP_200_OK)
    except ValueError as e:
        return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
    except Exception as e:
        return Response({'error': f"Erro interno: {str(e)}"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR), vc provavelmente vai mudar todos os arquivos e pra te norteia, os arquivos que ja passam nos testes sao: from django.test import TestCase
from rest_framework.test import APIClient
from rest_framework import status

class ConcatMonitorTestCase(TestCase):
    def setUp(self):
        self.client = APIClient()

    def test_concat_with_monitor(self):
        """Testa a geração de Python a partir de um Verilog com concatenação e $monitor."""
        input_code = (
            "module main (\n"
            "    input logic a,\n"
            "    input logic b,\n"
            "    input logic clk,\n"
            "    output logic [1:0] y\n"
            ");\n"
            "    reg [1:0] temp;\n"
            "    always @(posedge clk) begin\n"
            "        temp <= {a, b};\n"
            "        y <= temp;\n"
            "    end\n"
            "    initial begin\n"
            "        $monitor(\"Tempo: %t | a: %b | b: %b | y: %b\", $time, a, b, y);\n"
            "        #50 $finish;\n"
            "    end\n"
            "endmodule"
        )
        response = self.client.post('/api/compile-syslog-py/', {'code': input_code}, format='json')
        self.assertEqual(response.status_code, status.HTTP_200_OK, f"Erro na API: {response.json()}")

        data = response.json()
        py_code = data['python']

        expected_py_code = (
            "class Signal:\n"
            "    def __init__(self, value=0, bit_width=None):\n"
            "        self.value = value\n"
            "        self.bit_width = bit_width\n"
            "        if bit_width:\n"
            "            self.max_value = (1 << (bit_width[0] - bit_width[1] + 1)) - 1\n"
            "        self.prev_value = value  # Para detectar bordas\n"
            "\n"
            "    def set_value(self, value):\n"
            "        if self.bit_width:\n"
            "            self.value = value & self.max_value\n"
            "        else:\n"
            "            self.value = value\n"
            "\n"
            "\n"
            "class main:\n"
            "    def __init__(self):\n"
            "        self.a = Signal(bit_width=None)  # input, logic\n"
            "        self.b = Signal(bit_width=None)  # input, logic\n"
            "        self.clk = Signal(bit_width=None)  # input, logic\n"
            "        self.y = Signal(bit_width=(1, 0))  # output, logic, [1:0]\n"
            "        self.temp = Signal(bit_width=(1, 0))  # reg\n"
            "        self.time = 0  # Simulação de $time\n"
            "\n"
            "    def update_combinational(self):\n"
            "        pass\n"
            "\n"
            "    def update_sequential(self):\n"
            "        # Sensível a posedge de clk\n"
            "        # Simulação simplificada: atualiza na borda\n"
            "        if self.clk.value and not self.clk.prev_value:  # Borda positiva\n"
            "            self.temp.set_value((self.b.value << 0) | (self.a.value << 1))\n"
            "            self.y.set_value(self.temp.value)\n"
            "        self.clk.prev_value = self.clk.value\n"
            "\n"
            "    def run_initial(self):\n"
            "        # Simulação do bloco initial\n"
            "        print(f\"Tempo: {self.time} | a: {self.a.value:b} | b: {self.b.value:b} | y: {self.y.value:b}\")\n"
            "        if self.time == 50:\n"
            "            return False  # $finish\n"
            "        return True\n"
            "\n"
            "    def run(self):\n"
            "        while self.run_initial():\n"
            "            self.update_combinational()\n"
            "            self.update_sequential()\n"
            "            self.time += 1  # Passo de tempo baseado no clock\n"
            "\n"
            "# Teste manual\n"
            "if __name__ == \"__main__\":\n"
            "    sim = main()\n"
            "    sim.run()"
        )

        self.assertEqual(py_code.strip(), expected_py_code.strip(), "Código Python gerado não corresponde ao esperado.")

    def test_counter_reset_with_monitor(self):
        """Testa a geração de Python a partir de um Verilog com contador, reset e $monitor."""
        input_code = (
            "module main;\n"
            "    reg clk = 0;          // Clock interno inicializado em 0\n"
            "    reg reset = 1;        // Reset inicializado em 1\n"
            "    reg [3:0] counter;    // Contador de 4 bits (0 a 15)\n"
            "\n"
            "    // Gerador de clock\n"
            "    always #5 clk = ~clk;\n"
            "\n"
            "    // Lógica do contador com reset\n"
            "    always @(posedge clk) begin\n"
            "        if (reset) begin\n"
            "            counter <= 4'b0000;  // Reseta pra 0\n"
            "        end else begin\n"
            "            counter <= counter + 1;  // Incrementa o contador\n"
            "        end\n"
            "    end\n"
            "\n"
            "    // Monitoramento e simulação\n"
            "    initial begin\n"
            "        $monitor(\"Tempo: %t | clk: %b | reset: %b | counter: %d\", $time, clk, reset, counter);\n"
            "        #10 reset = 0;       // Desativa o reset após 10 unidades\n"
            "        #100 $finish;        // Termina após 100 unidades\n"
            "    end\n"
            "endmodule"
        )
        response = self.client.post('/api/compile-syslog-py/', {'code': input_code}, format='json')
        self.assertEqual(response.status_code, status.HTTP_200_OK, f"Erro na API: {response.json()}")

        data = response.json()
        py_code = data['python']

        expected_py_code = (
            "class Signal:\n"
            "    def __init__(self, value=0, bit_width=None):\n"
            "        self.value = value\n"
            "        self.bit_width = bit_width\n"
            "        if bit_width:\n"
            "            self.max_value = (1 << (bit_width[0] - bit_width[1] + 1)) - 1\n"
            "        self.prev_value = value  # Para detectar bordas\n"
            "\n"
            "    def set_value(self, value):\n"
            "        if self.bit_width:\n"
            "            self.value = value & self.max_value\n"
            "        else:\n"
            "            self.value = value\n"
            "\n"
            "\n"
            "class main:\n"
            "    def __init__(self):\n"
            "        self.clk = Signal(bit_width=None, value=0)  # reg\n"
            "        self.reset = Signal(bit_width=None, value=1)  # reg\n"
            "        self.counter = Signal(bit_width=(3, 0))  # reg\n"
            "        self.time = 0  # Simulação de $time\n"
            "\n"
            "    def update_combinational(self):\n"
            "        pass\n"
            "\n"
            "    def update_sequential(self):\n"
            "        # Clock gerado com atraso de 5 unidades\n"
            "        # Simulação simplificada: alterna o sinal\n"
            "        self.clk.set_value(1 - self.clk.value)\n"
            "        # Sensível a posedge de clk\n"
            "        # Simulação simplificada: atualiza na borda\n"
            "        if self.clk.value and not self.clk.prev_value:  # Borda positiva\n"
            "            if self.reset.value:\n"
            "                self.counter.set_value(0)\n"
            "            else:\n"
            "                self.counter.set_value(self.counter.value + 1)\n"
            "        self.clk.prev_value = self.clk.value\n"
            "\n"
            "    def run_initial(self):\n"
            "        # Simulação do bloco initial\n"
            "        print(f\"Tempo: {self.time} | clk: {self.clk.value:b} | reset: {self.reset.value:b} | counter: {self.counter.value}\")\n"
            "        if self.time == 10:\n"
            "            self.reset.set_value(0)\n"
            "        if self.time == 110:\n"
            "            return False  # $finish\n"
            "        return True\n"
            "\n"
            "    def run(self):\n"
            "        while self.run_initial():\n"
            "            self.update_combinational()\n"
            "            self.update_sequential()\n"
            "            self.time += 5  # Passo de tempo baseado no clock\n"
            "\n"
            "# Teste manual\n"
            "if __name__ == \"__main__\":\n"
            "    sim = main()\n"
            "    sim.run()"
        )

        self.assertEqual(py_code.strip(), expected_py_code.strip(), "Código Python gerado não corresponde ao esperado.")

    def test_counter_with_time_counter(self):
        """Testa a geração de Python a partir de um Verilog com contador, reset e time_counter."""
        input_code = (
            "module main;\n"
            "    // Sinais do sistema\n"
            "    reg clk = 0;\n"
            "    reg reset = 1;\n"
            "    reg [3:0] counter = 0;\n"
            "    \n"
            "    // Parâmetros de simulação\n"
            "    integer time_counter = 0;\n"
            "    \n"
            "    // Geração de clock\n"
            "    always #5 clk = ~clk;\n"
            "    \n"
            "    // Lógica sequencial\n"
            "    always @(posedge clk) begin\n"
            "        if (reset) begin\n"
            "            counter <= 0;\n"
            "        end else begin\n"
            "            counter <= counter + 1;\n"
            "        end\n"
            "    end\n"
            "    \n"
            "    // Bloco initial para simulação\n"
            "    initial begin\n"
            "        $monitor(\"Tempo: %0d | clk: %b | reset: %b | counter: %0d\", \n"
            "                 $time, clk, reset, counter);\n"
            "        #10 reset = 0;  // Desativa reset após 10 unidades de tempo\n"
            "        #100 $finish;  // Termina simulação após 100 unidades adicionais\n"
            "    end\n"
            "endmodule"
        )
        response = self.client.post('/api/compile-syslog-py/', {'code': input_code}, format='json')
        self.assertEqual(response.status_code, status.HTTP_200_OK, f"Erro na API: {response.json()}")

        data = response.json()
        py_code = data['python']

        expected_py_code = (
            "class Signal:\n"
            "    def __init__(self, value=0, bit_width=None):\n"
            "        self.value = value\n"
            "        self.bit_width = bit_width\n"
            "        if bit_width:\n"
            "            self.max_value = (1 << (bit_width[0] - bit_width[1] + 1)) - 1\n"
            "        self.prev_value = value  # Para detectar bordas\n"
            "\n"
            "    def set_value(self, value):\n"
            "        if self.bit_width:\n"
            "            self.value = value & self.max_value\n"
            "        else:\n"
            "            self.value = value\n"
            "\n"
            "\n"
            "class main:\n"
            "    def __init__(self):\n"
            "        self.clk = Signal(bit_width=None, value=0)  # reg\n"
            "        self.reset = Signal(bit_width=None, value=1)  # reg\n"
            "        self.counter = Signal(bit_width=(3, 0), value=0)  # reg\n"
            "        self.time = 0  # Simulação de $time\n"
            "\n"
            "    def update_combinational(self):\n"
            "        pass\n"
            "\n"
            "    def update_sequential(self):\n"
            "        # Clock gerado com atraso de 5 unidades\n"
            "        # Simulação simplificada: alterna o sinal\n"
            "        self.clk.set_value(1 - self.clk.value)\n"
            "        # Sensível a posedge de clk\n"
            "        # Simulação simplificada: atualiza na borda\n"
            "        if self.clk.value and not self.clk.prev_value:  # Borda positiva\n"
            "            if self.reset.value:\n"
            "                self.counter.set_value(0)\n"
            "            else:\n"
            "                self.counter.set_value(self.counter.value + 1)\n"
            "        self.clk.prev_value = self.clk.value\n"
            "\n"
            "    def run_initial(self):\n"
            "        # Simulação do bloco initial\n"
            "        print(f\"Tempo: {self.time} | clk: {self.clk.value:b} | reset: {self.reset.value:b} | counter: {self.counter.value}\")\n"
            "        if self.time == 10:\n"
            "            self.reset.set_value(0)\n"
            "        if self.time == 110:\n"
            "            return False  # $finish\n"
            "        return True\n"
            "\n"
            "    def run(self):\n"
            "        while self.run_initial():\n"
            "            self.update_combinational()\n"
            "            self.update_sequential()\n"
            "            self.time += 5  # Passo de tempo baseado no clock\n"
            "\n"
            "# Teste manual\n"
            "if __name__ == \"__main__\":\n"
            "    sim = main()\n"
            "    sim.run()"
        )

        self.assertEqual(py_code.strip(), expected_py_code.strip(), "Código Python gerado não corresponde ao esperado.")  from django.test import TestCase
from rest_framework.test import APIClient
from rest_framework import status

class SyslogPyNewTestCase(TestCase):
    def setUp(self):
        self.client = APIClient()

    def test_counter_with_monitor_new(self):
        """Testa a geração de Python a partir de um Verilog com contador, clock e $monitor."""
        input_code = (
            "/* \n"
            " * Do not change Module name \n"
            "*/\n"
            "module main;\n"
            "  reg clk = 0;\n"
            "  reg reset = 1;\n"
            "  reg [1:0] count;  // Contador de 2 bits (0 a 3)\n"
            "\n"
            "  // Gerador de clock\n"
            "  always #5 clk = ~clk;\n"
            "\n"
            "  // Lógica do contador\n"
            "  always @(posedge clk or posedge reset) begin\n"
            "    if (reset) \n"
            "      count <= 2'b00;  // Começa em 0\n"
            "    else if (count == 2'b11) // Se chegar em 3\n"
            "      count <= 2'b00;  // Reinicia\n"
            "    else\n"
            "      count <= count + 1; // Incrementa\n"
            "  end\n"
            "\n"
            "  initial begin\n"
            "    // Monitorar os valores\n"
            "    $monitor(\"Tempo: %t | Count: %d\", $time, count);\n"
            "    \n"
            "    // Reset inicial\n"
            "    #10 reset = 0;\n"
            "    \n"
            "    // Executa até contar até 3 duas vezes\n"
            "    #60 $finish;\n"
            "  end\n"
            "endmodule"
        )
        response = self.client.post('/api/compile-syslog-py/', {'code': input_code}, format='json')
        self.assertEqual(response.status_code, status.HTTP_200_OK, f"Erro na API: {response.json()}")

        data = response.json()
        py_code = data['python']

        expected_py_code = (
            "class Signal:\n"
            "    def __init__(self, value=0, bit_width=None):\n"
            "        self.value = value\n"
            "        self.bit_width = bit_width\n"
            "        if bit_width:\n"
            "            self.max_value = (1 << (bit_width[0] - bit_width[1] + 1)) - 1\n"
            "        self.prev_value = value  # Para detectar bordas\n"
            "\n"
            "    def set_value(self, value):\n"
            "        if self.bit_width:\n"
            "            self.value = value & self.max_value\n"
            "        else:\n"
            "            self.value = value\n"
            "\n"
            "\n"
            "class main:\n"
            "    def __init__(self):\n"
            "        self.clk = Signal(bit_width=None, value=0)  # reg\n"
            "        self.reset = Signal(bit_width=None, value=1)  # reg\n"
            "        self.count = Signal(bit_width=(1, 0))  # reg\n"
            "        self.time = 0  # Simulação de $time\n"
            "\n"
            "    def update_combinational(self):\n"
            "        pass\n"
            "\n"
            "    def update_sequential(self):\n"
            "        # Clock gerado com atraso de 5 unidades\n"
            "        # Simulação simplificada: alterna o sinal\n"
            "        self.clk.set_value(1 - self.clk.value)\n"
            "        # Sensível a posedge de clk, posedge de reset\n"
            "        # Simulação simplificada: atualiza na borda\n"
            "        if self.clk.value and not self.clk.prev_value or self.reset.value and not self.reset.prev_value:  # Borda positiva\n"
            "            if self.reset.value:\n"
            "                self.count.set_value(0)\n"
            "            elif self.count.value == 3:\n"
            "                self.count.set_value(0)\n"
            "            else:\n"
            "                self.count.set_value(self.count.value + 1)\n"
            "        self.clk.prev_value = self.clk.value\n"
            "        self.reset.prev_value = self.reset.value\n"
            "\n"
            "    def run_initial(self):\n"
            "        # Simulação do bloco initial\n"
            "        print(f\"Tempo: {self.time} | Count: {self.count.value}\")\n"
            "        if self.time == 10:\n"
            "            self.reset.set_value(0)\n"
            "        if self.time == 70:\n"
            "            return False  # $finish\n"
            "        return True\n"
            "\n"
            "    def run(self):\n"
            "        while self.run_initial():\n"
            "            self.update_combinational()\n"
            "            self.update_sequential()\n"
            "            self.time += 5  # Passo de tempo baseado no clock\n"
            "\n"
            "# Teste manual\n"
            "if __name__ == \"__main__\":\n"
            "    sim = main()\n"
            "    sim.run()"
        )

        self.assertEqual(py_code.strip(), expected_py_code.strip(), "Código Python gerado não corresponde ao esperado.")
        
    def test_simple_clock_new(self):
        """Testa a geração de Python a partir de um Verilog simples com clock e $finish."""
        input_code = (
            "module main;\n"
            "  reg clk = 0;\n"
            "  always #5 clk = ~clk;\n"
            "  initial begin\n"
            "    #50 $finish;\n"
            "  end\n"
            "endmodule"
        )
        response = self.client.post('/api/compile-syslog-py/', {'code': input_code}, format='json')
        self.assertEqual(response.status_code, status.HTTP_200_OK, f"Erro na API: {response.json()}")

        data = response.json()
        py_code = data['python']

        expected_py_code = (
            "class Signal:\n"
            "    def __init__(self, value=0, bit_width=None):\n"
            "        self.value = value\n"
            "        self.bit_width = bit_width\n"
            "        if bit_width:\n"
            "            self.max_value = (1 << (bit_width[0] - bit_width[1] + 1)) - 1\n"
            "        self.prev_value = value  # Para detectar bordas\n"
            "\n"
            "    def set_value(self, value):\n"
            "        if self.bit_width:\n"
            "            self.value = value & self.max_value\n"
            "        else:\n"
            "            self.value = value\n"
            "\n"
            "\n"
            "class main:\n"
            "    def __init__(self):\n"
            "        self.clk = Signal(bit_width=None, value=0)  # reg\n"
            "        self.time = 0  # Simulação de $time\n"
            "\n"
            "    def update_combinational(self):\n"
            "        pass\n"
            "\n"
            "    def update_sequential(self):\n"
            "        # Clock gerado com atraso de 5 unidades\n"
            "        # Simulação simplificada: alterna o sinal\n"
            "        self.clk.set_value(1 - self.clk.value)\n"
            "\n"
            "    def run_initial(self):\n"
            "        # Simulação do bloco initial\n"
            "        if self.time == 50:\n"
            "            return False  # $finish\n"
            "        return True\n"
            "\n"
            "    def run(self):\n"
            "        while self.run_initial():\n"
            "            self.update_combinational()\n"
            "            self.update_sequential()\n"
            "            self.time += 5  # Passo de tempo baseado no clock\n"
            "\n"
            "# Teste manual\n"
            "if __name__ == \"__main__\":\n"
            "    sim = main()\n"
            "    sim.run()"
        )

        self.assertEqual(py_code.strip(), expected_py_code.strip(), "Código Python gerado não corresponde ao esperado.")