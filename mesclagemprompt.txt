olá preciso que vcx analise algusncodigos meus e encontre as diferenças entre o inicial, mescle eles e faça com que os testes rodem todos.: 

[
class Parser:
    def __init__(self, tokens):
        self.tokens = tokens
        self.pos = 0
        print("Iniciando parser com tokens:", tokens)

    def current_token(self):
        token = self.tokens[self.pos] if self.pos < len(self.tokens) else (None, None)
        print(f"Token atual (pos {self.pos}): {token}")
        return token

    def consume(self, expected_type=None, expected_value=None):
        token_type, token_value = self.current_token()
        if (expected_type and token_type != expected_type) or (expected_value and token_value != expected_value):
            raise ValueError(f"Esperado {expected_type} {expected_value}, encontrado {token_type} {token_value}")
        self.pos += 1
        print(f"Consumido: ({token_type}, {token_value})")
        return token_type, token_value

    def parse(self):
        ast = {'type': 'Program', 'body': []}
        print("Parsing programa...")
        while self.pos < len(self.tokens):
            token_type, token_value = self.current_token()
            if token_type == 'KEYWORD' and token_value == 'module':
                ast['body'].append(self.parse_module())
            else:
                self.pos += 1
        print("AST gerado:", ast)
        return ast

    def parse_module(self):
        print("Parsing module...")
        self.consume('KEYWORD', 'module')
        _, module_name = self.consume('IDENTIFIER')
        
        ports = []
        if self.current_token()[1] == '(':  # Portas são opcionais
            self.consume('SYMBOL', '(')
            while self.current_token()[1] != ')':
                ports.append(self.parse_port())
                if self.current_token()[1] == ',':
                    self.consume('SYMBOL', ',')
                elif self.current_token()[1] != ')':
                    raise ValueError(f"Esperado ',' ou ')', encontrado {self.current_token()[1]}")
            self.consume('SYMBOL', ')')
        
        self.consume('SYMBOL', ';')

        body = []
        while self.pos < len(self.tokens) and self.current_token()[1] != 'endmodule':
            token_type, token_value = self.current_token()
            if token_value in ('input', 'output', 'inout', 'wire', 'reg'):
                body.append(self.parse_declaration())
            elif token_value == 'assign':
                body.append(self.parse_assign())
            elif token_value == 'always':
                body.append(self.parse_always())
            elif token_value == 'initial':
                body.append(self.parse_initial())
            else:
                print(f"Ignorando token no corpo do módulo: {token_type} {token_value}")
                self.pos += 1
        self.consume('KEYWORD', 'endmodule')
        return {'type': 'Module', 'name': module_name, 'ports': ports, 'body': body}

    def parse_bit_width(self):
        if self.current_token()[1] != '[':
            return None
        self.consume('SYMBOL', '[')
        
        high = 0
        if self.current_token()[0] == 'NUMBER':
            _, high = self.consume('NUMBER')
        
        self.consume('OPERATOR', ':')
        
        low = 0
        if self.current_token()[0] == 'NUMBER':
            _, low = self.consume('NUMBER')
        
        self.consume('SYMBOL', ']')
        return (int(high), int(low))

    def parse_port(self):
        print("Parsing port...")
        port_type = self.current_token()[1]
        if port_type not in ('input', 'output', 'inout'):
            raise ValueError(f"Tipo de porta inválido: {port_type}")
        self.consume('KEYWORD')

        data_type = None
        if self.current_token()[1] == 'logic':
            data_type = self.current_token()[1]
            self.consume('IDENTIFIER')

        bit_width = self.parse_bit_width() if self.current_token()[1] == '[' else None

        _, port_name = self.consume('IDENTIFIER')
        
        return {
            'type': port_type,
            'name': port_name,
            'data_type': data_type,
            'bit_width': bit_width
        }

    def parse_declaration(self):
        print("Parsing declaration...")
        decl_type = self.current_token()[1]
        self.consume('KEYWORD')

        bit_width = None
        if self.current_token()[1] == '[':
            bit_width = self.parse_bit_width()

        _, name = self.consume('IDENTIFIER')
        
        initial_value = None
        if self.current_token()[1] == '=':
            self.consume('OPERATOR', '=')
            _, initial_value = self.consume('NUMBER')
            initial_value = int(initial_value)
        
        self.consume('SYMBOL', ';')
        return {
            'type': 'Declaration', 
            'decl_type': decl_type, 
            'name': name, 
            'bit_width': bit_width, 
            'initial_value': initial_value
        }

    def parse_assign(self):
        print("Parsing assign...")
        self.consume('KEYWORD', 'assign')
        _, lhs = self.consume('IDENTIFIER')
        self.consume('OPERATOR', '=')
        rhs = self.parse_expression()
        self.consume('SYMBOL', ';')
        return {'type': 'Assign', 'lhs': lhs, 'rhs': rhs}

    def parse_always(self):
        print("Parsing always...")
        self.consume('KEYWORD', 'always')
        
        delay = None
        sensitivity_list = []
        token_type, token_value = self.current_token()
        
        if token_value == '#':
            self.consume('OPERATOR', '#')
            _, delay_value = self.consume('NUMBER')
            delay = int(delay_value)
            
            _, lhs = self.consume('IDENTIFIER')
            self.consume('OPERATOR', '=') 
            rhs = self.parse_expression()
            self.consume('SYMBOL', ';')
            
            return {'type': 'AlwaysDelay', 'delay': delay, 'statement': {'type': 'Assignment', 'lhs': lhs, 'rhs': rhs}}
        
        elif token_value == '@':
            self.consume('SYMBOL', '@')
            
            has_paren = self.current_token()[1] == '('
            if has_paren:
                self.consume('SYMBOL', '(')
            
            while True:
                edge = None
                if self.current_token()[1] in ('posedge', 'negedge'):
                    edge = self.current_token()[1]
                    self.consume('KEYWORD')
                
                _, signal = self.consume('IDENTIFIER')
                sensitivity_list.append({'edge': edge, 'signal': signal})
                
                next_token = self.current_token()
                if has_paren and next_token[1] == ')':
                    break
                elif not has_paren and next_token[1] == 'begin':
                    break
                elif next_token[1] in (',', 'or'):
                    self.consume()
                else:
                    raise ValueError(f"Esperado ',', 'or' ou ')', encontrado {next_token[1]}")
            
            if has_paren:
                self.consume('SYMBOL', ')')
            
            self.consume('KEYWORD', 'begin')
            
            statements = []
            while self.current_token()[1] != 'end':
                statements.append(self.parse_statement())
            
            self.consume('KEYWORD', 'end')
            return {'type': 'Always', 'sensitivity_list': sensitivity_list, 'statements': statements}
        
        else:
            raise ValueError(f"Esperado '@' ou '#', encontrado {token_value}")

    def parse_initial(self):
        print("Parsing initial...")
        self.consume('KEYWORD', 'initial')
        self.consume('KEYWORD', 'begin')
        
        statements = []
        while self.current_token()[1] != 'end':
            token_type, token_value = self.current_token()
            if token_value == '$monitor':
                statements.append(self.parse_monitor())
            elif token_value == '#':
                statements.append(self.parse_delay())
            else:
                statements.append(self.parse_statement())
        
        self.consume('KEYWORD', 'end')
        return {'type': 'Initial', 'statements': statements}

    def parse_monitor(self):
        print("Parsing $monitor...")
        self.consume('KEYWORD', '$monitor')
        self.consume('SYMBOL', '(')
        
        args = []
        while self.current_token()[1] != ')':
            if self.current_token()[0] == 'STRING':
                _, string = self.consume('STRING')
                args.append({'type': 'String', 'value': string})
            else:
                args.append({'type': 'Expression', 'value': self.parse_expression()})
            if self.current_token()[1] == ',':
                self.consume('SYMBOL', ',')
        
        self.consume('SYMBOL', ')')
        self.consume('SYMBOL', ';')
        return {'type': 'Monitor', 'args': args}

    def parse_delay(self):
        print("Parsing delay...")
        self.consume('OPERATOR', '#')
        _, delay_value = self.consume('NUMBER')
        
        if self.current_token()[1] == '$finish':
            self.consume('KEYWORD', '$finish')
            self.consume('SYMBOL', ';')
            return {'type': 'Finish', 'delay': int(delay_value)}
        else:
            _, lhs = self.consume('IDENTIFIER')
            self.consume('OPERATOR', '=')  # Suporta '='
            rhs = self.parse_expression()
            self.consume('SYMBOL', ';')
            return {'type': 'DelayAssignment', 'delay': int(delay_value), 'lhs': lhs, 'rhs': rhs}

    def parse_statement(self):
        print("Parsing statement...")
        token_type, token_value = self.current_token()
        if token_value == 'if':
            return self.parse_if()
        else:
            _, lhs = self.consume('IDENTIFIER')
            op_type, op_value = self.consume('OPERATOR')
            if op_value not in ('=', '<='):
                raise ValueError(f"Esperado '=' ou '<=', encontrado {op_value}")
            rhs = self.parse_expression()
            self.consume('SYMBOL', ';')
            return {'type': 'Assignment', 'lhs': lhs, 'rhs': rhs, 'operator': op_value}

    def parse_if(self):
        print("Parsing if...")
        self.consume('KEYWORD', 'if')
        self.consume('SYMBOL', '(')
        condition = self.parse_expression()
        self.consume('SYMBOL', ')')
        
        true_statements = []
        if self.current_token()[1] == 'begin':
            self.consume('KEYWORD', 'begin')
            while self.current_token()[1] != 'end':
                true_statements.append(self.parse_statement())
            self.consume('KEYWORD', 'end')
        else:
            true_statements.append(self.parse_statement())
        
        false_statements = []
        if self.current_token()[1] == 'else':
            self.consume('KEYWORD', 'else')
            if self.current_token()[1] == 'begin':
                self.consume('KEYWORD', 'begin')
                while self.current_token()[1] != 'end':
                    false_statements.append(self.parse_statement())
                self.consume('KEYWORD', 'end')
            else:
                false_statements.append(self.parse_statement())
        
        return {'type': 'If', 'condition': condition, 'true_statements': true_statements, 'false_statements': false_statements}

    def parse_expression(self):
        print("Parsing expression...")
        expr = []
        while self.current_token()[1] not in (';', ')', 'begin', 'end'):
            token_type, token_value = self.current_token()
            print(f"Analisando token na expressão: ({token_type}, {token_value})")
            
            if token_type == 'SYMBOL' and token_value == '{':  # Início de concatenação
                print("Detectado início de concatenação '{'")
                expr.append(('OPERATOR', 'CONCAT_START'))
                self.consume('SYMBOL', '{')
                concat_elements = []
                
                while self.current_token()[1] != '}':
                    print(f"Parsing elemento dentro de {{}}: {self.current_token()}")
                    if self.current_token()[0] in ('IDENTIFIER', 'NUMBER'):
                        concat_elements.append(self.parse_simple_expression())
                    else:
                        raise ValueError(f"Esperado identificador ou número em concatenação, encontrado {self.current_token()}")
                    
                    if self.current_token()[1] == ',':
                        self.consume('SYMBOL', ',')
                        print("Vírgula consumida em concatenação")
                    elif self.current_token()[1] != '}':
                        raise ValueError(f"Esperado ',' ou '}}', encontrado {self.current_token()[1]}")
                
                self.consume('SYMBOL', '}')
                print("Detectado fim de concatenação '}'")
                expr.append(('CONCAT', concat_elements))
                expr.append(('OPERATOR', 'CONCAT_END'))
            
            elif token_type in ('IDENTIFIER', 'NUMBER', 'STRING'):
                expr.append((token_type, token_value))
                self.consume()
            elif token_type == 'OPERATOR':
                expr.append((token_type, token_value))
                self.consume()
            elif token_value == '(':
                expr.append(('SYMBOL', '('))
                self.consume()
                expr.extend(self.parse_expression())
                self.consume('SYMBOL', ')')
                expr.append(('SYMBOL', ')'))
            else:
                self.consume()  # Avança em caso de tokens desconhecidos
            
            print(f"Estado atual da expressão: {expr}")
        
        print(f"Expressão parseada: {expr}")
        return expr

    def parse_simple_expression(self):
        """Helper para parsear expressões simples dentro de concatenações"""
        token_type, token_value = self.current_token()
        print(f"Parsing expressão simples: ({token_type}, {token_value})")
        if token_type in ('IDENTIFIER', 'NUMBER'):
            self.consume()
            return (token_type, token_value)
        raise ValueError(f"Esperado IDENTIFIER ou NUMBER, encontrado {token_type} {token_value}")

def parse(tokens):
    parser = Parser(tokens)
    return parser.parse()

 ]


e o finaal:

[
class Parser:
    def __init__(self, tokens):
        self.tokens = tokens
        self.pos = 0
        print("Iniciando parser com tokens:", tokens)

    def current_token(self):
        token = self.tokens[self.pos] if self.pos < len(self.tokens) else (None, None)
        print(f"Token atual (pos {self.pos}): {token}")
        return token

    def consume(self, expected_type=None, expected_value=None):
        token_type, token_value = self.current_token()
        if (expected_type and token_type != expected_type) or (expected_value and token_value != expected_value):
            raise ValueError(f"Esperado {expected_type} {expected_value}, encontrado {token_type} {token_value}")
        self.pos += 1
        print(f"Consumido: ({token_type}, {token_value})")
        return token_type, token_value

    def parse(self):
        ast = {'type': 'Program', 'body': []}
        print("Parsing programa...")
        while self.pos < len(self.tokens):
            token_type, token_value = self.current_token()
            if token_type == 'KEYWORD' and token_value == 'module':
                ast['body'].append(self.parse_module())
            else:
                self.pos += 1
        print("AST gerado:", ast)
        return ast

    def parse_module(self):
        print("Parsing module...")
        self.consume('KEYWORD', 'module')
        _, module_name = self.consume('IDENTIFIER')
        
        ports = []
        if self.current_token()[1] == '(':
            self.consume('SYMBOL', '(')
            while self.current_token()[1] != ')':
                ports.append(self.parse_port())
                if self.current_token()[1] == ',':
                    self.consume('SYMBOL', ',')
                elif self.current_token()[1] != ')':
                    raise ValueError(f"Esperado ',' ou ')', encontrado {self.current_token()[1]}")
            self.consume('SYMBOL', ')')
        
        self.consume('SYMBOL', ';')

        body = []
        while self.pos < len(self.tokens) and self.current_token()[1] != 'endmodule':
            token_type, token_value = self.current_token()
            if token_value in ('input', 'output', 'inout', 'wire', 'reg', 'logic'):
                decl = self.parse_declaration()
                if isinstance(decl, list):
                    body.extend(decl)
                else:
                    body.append(decl)
            elif token_value == 'assign':
                body.append(self.parse_assign())
            elif token_value == 'always':
                body.append(self.parse_always())
            elif token_value == 'initial':
                body.append(self.parse_initial())
            else:
                print(f"Ignorando token no corpo do módulo: {token_type} {token_value}")
                self.pos += 1
        self.consume('KEYWORD', 'endmodule')
        return {'type': 'Module', 'name': module_name, 'ports': ports, 'body': body}

    def parse_bit_width(self):
        if self.current_token()[1] != '[':
            return None
        self.consume('SYMBOL', '[')
        
        high = 0
        if self.current_token()[0] == 'NUMBER':
            _, high = self.consume('NUMBER')
        
        self.consume('OPERATOR', ':')
        
        low = 0
        if self.current_token()[0] == 'NUMBER':
            _, low = self.consume('NUMBER')
        
        self.consume('SYMBOL', ']')
        return (int(high), int(low))

    def parse_port(self):
        print("Parsing port...")
        port_type = self.current_token()[1]
        if port_type not in ('input', 'output', 'inout'):
            raise ValueError(f"Tipo de porta inválido: {port_type}")
        self.consume('KEYWORD')

        data_type = None
        if self.current_token()[1] == 'logic':
            data_type = self.current_token()[1]
            self.consume('KEYWORD')

        bit_width = self.parse_bit_width() if self.current_token()[1] == '[' else None

        _, port_name = self.consume('IDENTIFIER')
        
        return {
            'type': port_type,
            'name': port_name,
            'data_type': data_type,
            'bit_width': bit_width
        }

    def parse_declaration(self):
        print("Parsing declaration...")
        decl_type = self.current_token()[1]
        if decl_type not in ('reg', 'wire', 'logic'):
            raise ValueError(f"Tipo de declaração inválido: {decl_type}")
        self.consume('KEYWORD')

        bit_width = None
        if self.current_token()[1] == '[':
            bit_width = self.parse_bit_width()

        declarations = []
        while self.current_token()[1] != ';':
            _, name = self.consume('IDENTIFIER')
            
            initial_value = None
            if self.current_token()[1] == '=':
                self.consume('OPERATOR', '=')
                _, initial_value = self.consume('NUMBER')
                initial_value = int(initial_value)
            
            declarations.append({
                'type': 'Declaration',
                'decl_type': decl_type,
                'name': name,
                'bit_width': bit_width,
                'initial_value': initial_value
            })
            
            if self.current_token()[1] == ',':
                self.consume('SYMBOL', ',')
            elif self.current_token()[1] != ';':
                raise ValueError(f"Esperado ',' ou ';', encontrado {self.current_token()[1]}")
        
        self.consume('SYMBOL', ';')
        return declarations if len(declarations) > 1 else declarations[0]

    def parse_assign(self):
        print("Parsing assign...")
        self.consume('KEYWORD', 'assign')
        _, lhs = self.consume('IDENTIFIER')
        self.consume('OPERATOR', '=')
        rhs = self.parse_expression()
        self.consume('SYMBOL', ';')
        return {'type': 'Assign', 'lhs': lhs, 'rhs': rhs}

    def parse_always(self):
        print("Parsing always...")
        self.consume('KEYWORD', 'always')
        
        delay = None
        sensitivity_list = []
        token_type, token_value = self.current_token()
        
        if token_value == '#':
            self.consume('OPERATOR', '#')
            _, delay_value = self.consume('NUMBER')
            delay = int(delay_value)
            
            _, lhs = self.consume('IDENTIFIER')
            self.consume('OPERATOR', '=') 
            rhs = self.parse_expression()
            self.consume('SYMBOL', ';')
            
            return {'type': 'AlwaysDelay', 'delay': delay, 'statement': {'type': 'Assignment', 'lhs': lhs, 'rhs': rhs}}
        
        elif token_value == '@':
            self.consume('SYMBOL', '@')
            
            has_paren = self.current_token()[1] == '('
            if has_paren:
                self.consume('SYMBOL', '(')
            
            while True:
                edge = None
                if self.current_token()[1] in ('posedge', 'negedge'):
                    edge = self.current_token()[1]
                    self.consume('KEYWORD')
                
                _, signal = self.consume('IDENTIFIER')
                sensitivity_list.append({'edge': edge, 'signal': signal})
                
                next_token = self.current_token()
                if has_paren and next_token[1] == ')':
                    break
                elif not has_paren and next_token[1] == 'begin':
                    break
                elif next_token[1] in (',', 'or'):
                    self.consume()
                else:
                    raise ValueError(f"Esperado ',', 'or' ou ')', encontrado {next_token[1]}")
            
            if has_paren:
                self.consume('SYMBOL', ')')
            
            self.consume('KEYWORD', 'begin')
            
            statements = []
            while self.current_token()[1] != 'end':
                statements.append(self.parse_statement())
            
            self.consume('KEYWORD', 'end')
            return {'type': 'Always', 'sensitivity_list': sensitivity_list, 'statements': statements}
        
        else:
            raise ValueError(f"Esperado '@' ou '#', encontrado {token_value}")

    def parse_initial(self):
        print("Parsing initial...")
        self.consume('KEYWORD', 'initial')
        self.consume('KEYWORD', 'begin')
        
        statements = []
        while self.current_token()[1] != 'end':
            token_type, token_value = self.current_token()
            if token_value == '$monitor':
                statements.append(self.parse_monitor())
            elif token_value == '$display':
                statements.append(self.parse_display())
            elif token_value == '#':
                statements.append(self.parse_delay())
            elif token_value == 'repeat':
                statements.append(self.parse_repeat())
            else:
                statements.append(self.parse_statement())
        
        self.consume('KEYWORD', 'end')
        return {'type': 'Initial', 'statements': statements}

    def parse_monitor(self):
        print("Parsing $monitor...")
        self.consume('KEYWORD', '$monitor')
        self.consume('SYMBOL', '(')
        
        args = []
        while self.current_token()[1] != ')':
            if self.current_token()[0] == 'STRING':
                _, string = self.consume('STRING')
                args.append({'type': 'String', 'value': string})
            else:
                args.append({'type': 'Expression', 'value': self.parse_expression()})
            if self.current_token()[1] == ',':
                self.consume('SYMBOL', ',')
        
        self.consume('SYMBOL', ')')
        self.consume('SYMBOL', ';')
        return {'type': 'Monitor', 'args': args}

    def parse_display(self):
        print("Parsing $display...")
        self.consume('KEYWORD', '$display')
        self.consume('SYMBOL', '(')
        
        args = []
        while self.current_token()[1] != ')':
            if self.current_token()[0] == 'STRING':
                _, string = self.consume('STRING')
                args.append({'type': 'String', 'value': string})
            else:
                args.append({'type': 'Expression', 'value': self.parse_expression()})
            if self.current_token()[1] == ',':
                self.consume('SYMBOL', ',')
        
        self.consume('SYMBOL', ')')
        self.consume('SYMBOL', ';')
        return {'type': 'Display', 'args': args}

    def parse_delay(self):
        print("Parsing delay...")
        self.consume('OPERATOR', '#')
        _, delay_value = self.consume('NUMBER')
        
        if self.current_token()[1] == '$finish':
            self.consume('KEYWORD', '$finish')
            self.consume('SYMBOL', ';')
            return {'type': 'Finish', 'delay': int(delay_value)}
        else:
            _, lhs = self.consume('IDENTIFIER')
            self.consume('OPERATOR', '=')  # Suporta '='
            rhs = self.parse_expression()
            self.consume('SYMBOL', ';')
            return {'type': 'DelayAssignment', 'delay': int(delay_value), 'lhs': lhs, 'rhs': rhs}

    def parse_repeat(self):
        print("Parsing repeat...")
        self.consume('KEYWORD', 'repeat')
        self.consume('SYMBOL', '(')
        _, count = self.consume('NUMBER')
        self.consume('SYMBOL', ')')
        
        repeated_stmt = self.parse_delay()  # Assume que o repeat é seguido por um delay
        return {'type': 'Repeat', 'count': int(count), 'statement': repeated_stmt}

    def parse_statement(self):
        print("Parsing statement...")
        token_type, token_value = self.current_token()
        if token_value == 'if':
            return self.parse_if()
        elif token_value == '$display':
            return self.parse_display()
        else:
            _, lhs = self.consume('IDENTIFIER')
            op_type, op_value = self.consume('OPERATOR')
            if op_value not in ('=', '<='):
                raise ValueError(f"Esperado '=' ou '<=', encontrado {op_value}")
            rhs = self.parse_expression()
            self.consume('SYMBOL', ';')
            return {'type': 'Assignment', 'lhs': lhs, 'rhs': rhs, 'operator': op_value}

    def parse_if(self):
        print("Parsing if...")
        self.consume('KEYWORD', 'if')
        self.consume('SYMBOL', '(')
        condition = self.parse_expression()
        self.consume('SYMBOL', ')')
        
        true_statements = []
        if self.current_token()[1] == 'begin':
            self.consume('KEYWORD', 'begin')
            while self.current_token()[1] != 'end':
                true_statements.append(self.parse_statement())
            self.consume('KEYWORD', 'end')
        else:
            true_statements.append(self.parse_statement())
        
        false_statements = []
        if self.current_token()[1] == 'else':
            self.consume('KEYWORD', 'else')
            if self.current_token()[1] == 'begin':
                self.consume('KEYWORD', 'begin')
                while self.current_token()[1] != 'end':
                    false_statements.append(self.parse_statement())
                self.consume('KEYWORD', 'end')
            else:
                false_statements.append(self.parse_statement())
        
        return {'type': 'If', 'condition': condition, 'true_statements': true_statements, 'false_statements': false_statements}

    def parse_expression(self):
        print("Parsing expression...")
        expr = []
        while self.current_token()[1] not in (';', ')', 'begin', 'end'):
            token_type, token_value = self.current_token()
            print(f"Analisando token na expressão: ({token_type}, {token_value})")
            
            if token_type == 'OPERATOR' and token_value == '?':
                condition = expr if expr else self.parse_expression()  # Condição pode ser uma subexpressão
                self.consume('OPERATOR', '?')
                true_expr = self.parse_ternary_part(until=':')  # Parseia até o ':'
                self.consume('OPERATOR', ':')
                false_expr = self.parse_ternary_part(until=';')  # Parseia até o ';'
                return [{'type': 'Ternary', 'condition': condition, 'true': true_expr, 'false': false_expr}]
            
            if token_type == 'SYMBOL' and token_value == '{':
                print("Detectado início de concatenação '{'")
                expr.append(('OPERATOR', 'CONCAT_START'))
                self.consume('SYMBOL', '{')
                concat_elements = []
                
                while self.current_token()[1] != '}':
                    print(f"Parsing elemento dentro de {{}}: {self.current_token()}")
                    if self.current_token()[0] in ('IDENTIFIER', 'NUMBER'):
                        concat_elements.append(self.parse_simple_expression())
                    else:
                        raise ValueError(f"Esperado identificador ou número em concatenação, encontrado {self.current_token()}")
                    
                    if self.current_token()[1] == ',':
                        self.consume('SYMBOL', ',')
                        print("Vírgula consumida em concatenação")
                    elif self.current_token()[1] != '}':
                        raise ValueError(f"Esperado ',' ou '}}', encontrado {self.current_token()[1]}")
                
                self.consume('SYMBOL', '}')
                print("Detectado fim de concatenação '}'")
                expr.append(('CONCAT', concat_elements))
                expr.append(('OPERATOR', 'CONCAT_END'))
            
            elif token_type in ('IDENTIFIER', 'NUMBER', 'STRING'):
                expr.append((token_type, token_value))
                self.consume()
            elif token_type == 'OPERATOR':
                expr.append((token_type, token_value))
                self.consume()
            elif token_value == '(':
                expr.append(('SYMBOL', '('))
                self.consume()
                sub_expr = self.parse_expression()
                expr.extend(sub_expr)
                self.consume('SYMBOL', ')')
                expr.append(('SYMBOL', ')'))
            else:
                self.consume()
            
            print(f"Estado atual da expressão: {expr}")
        
        print(f"Expressão parseada: {expr}")
        return expr

    def parse_ternary_part(self, until):
        """Helper para parsear partes do ternário até um delimitador específico"""
        print(f"Parsing parte do ternário até '{until}'...")
        expr = []
        while self.current_token()[1] not in (until,):
            token_type, token_value = self.current_token()
            print(f"Analisando token na parte do ternário: ({token_type}, {token_value})")
            
            if token_type in ('IDENTIFIER', 'NUMBER', 'STRING'):
                expr.append((token_type, token_value))
                self.consume()
            elif token_type == 'OPERATOR':
                expr.append((token_type, token_value))
                self.consume()
            elif token_value == '(':
                expr.append(('SYMBOL', '('))
                self.consume()
                sub_expr = self.parse_expression()
                expr.extend(sub_expr)
                self.consume('SYMBOL', ')')
                expr.append(('SYMBOL', ')'))
            else:
                raise ValueError(f"Token inesperado na parte do ternário: {self.current_token()}")
            
            print(f"Estado atual da parte do ternário: {expr}")
        
        print(f"Parte do ternário parseada: {expr}")
        return expr if len(expr) > 1 else expr[0] if expr else []

    def parse_simple_expression(self):
        """Helper para parsear expressões simples dentro de concatenações"""
        token_type, token_value = self.current_token()
        print(f"Parsing expressão simples: ({token_type}, {token_value})")
        if token_type in ('IDENTIFIER', 'NUMBER'):
            self.consume()
            return (token_type, token_value)
        raise ValueError(f"Esperado IDENTIFIER ou NUMBER, encontrado {token_type} {token_value}")

def parse(tokens):
    parser = Parser(tokens)
    return parser.parse()

]


agr vamos para o generator 


antigo que funcionava os testes assim como o original do parse:

[
def generate_python(ast):
    print("Iniciando geração de código Python com AST:", ast)
    python_code = []
    python_code.append("class Signal:\n    def __init__(self, value=0, bit_width=None):\n        self.value = value\n        self.bit_width = bit_width\n        if bit_width:\n            self.max_value = (1 << (bit_width[0] - bit_width[1] + 1)) - 1\n        self.prev_value = value  # Para detectar bordas\n\n    def set_value(self, value):\n        if self.bit_width:\n            self.value = value & self.max_value\n        else:\n            self.value = value\n\n")

    for node in ast['body']:
        if node['type'] == 'Module':
            module_name = node['name']
            ports = node['ports']
            body = node['body']

            python_code.append(f"class {module_name}:")
            python_code.append("    def __init__(self):")
            print(f"Gerando __init__ para módulo {module_name}")

            for port in ports:
                port_name = port['name']
                bit_width = port.get('bit_width')
                data_type = port.get('data_type', '')
                comment = f"{port['type']}"
                if data_type:
                    comment += f", {data_type}"
                if bit_width:
                    comment += f", [{bit_width[0]}:{bit_width[1]}]"
                python_code.append(f"        self.{port_name} = Signal(bit_width={bit_width})  # {comment}")
                print(f"Adicionado porto: self.{port_name}")

            for stmt in body:
                if stmt['type'] == 'Declaration':
                    var_name = stmt['name']
                    bit_width = stmt.get('bit_width')
                    initial_value = stmt.get('initial_value')
                    value_str = f", value={initial_value}" if initial_value is not None else ""
                    python_code.append(f"        self.{var_name} = Signal(bit_width={bit_width}{value_str})  # {stmt['decl_type']}")
                    print(f"Adicionada declaração: self.{var_name}")

            python_code.append("        self.time = 0  # Simulação de $time")

            python_code.append("\n    def update_combinational(self):")
            combinational_found = False
            for stmt in body:
                if stmt['type'] == 'Assign':
                    lhs = stmt['lhs']
                    rhs = translate_expression(stmt['rhs'])
                    python_code.append(f"        self.{lhs}.set_value({rhs})")
                    print(f"Adicionada atribuição combinacional: self.{lhs}.set_value({rhs})")
                    combinational_found = True
            if not combinational_found:
                python_code.append("        pass")

            python_code.append("\n    def update_sequential(self):")
            sequential_found = False
            clock_delay = None
            for stmt in body:
                if stmt['type'] == 'AlwaysDelay':
                    clock_delay = stmt['delay']
                    python_code.append(f"        # Clock gerado com atraso de {stmt['delay']} unidades")
                    python_code.append(f"        # Simulação simplificada: alterna o sinal")
                    python_code.append(translate_statement(stmt['statement'], indent=2))
                    print(f"Adicionado AlwaysDelay com delay {stmt['delay']}")
                    sequential_found = True
                elif stmt['type'] == 'Always':
                    sensitivity_list = stmt['sensitivity_list']
                    statements = stmt['statements']
                    sensitivity_comment = "        # Sensível a " + ", ".join(
                        f"{s['edge']} de {s['signal']}" if s['edge'] else s['signal'] 
                        for s in sensitivity_list
                    )
                    python_code.append(sensitivity_comment)
                    python_code.append("        # Simulação simplificada: atualiza na borda")
                    conditions = []
                    for s in sensitivity_list:
                        if s['edge'] == 'posedge':
                            signal = s['signal']
                            conditions.append(f"self.{signal}.value and not self.{signal}.prev_value")
                    if conditions:
                        python_code.append(f"        if {' or '.join(conditions)}:  # Borda positiva")
                        for sub_stmt in statements:
                            python_code.append(translate_statement(sub_stmt, indent=3))
                        for s in sensitivity_list:
                            if s['edge'] == 'posedge':
                                signal = s['signal']
                                python_code.append(f"        self.{signal}.prev_value = self.{signal}.value")
                    else:
                        for sub_stmt in statements:
                            python_code.append(translate_statement(sub_stmt, indent=2))
                    print(f"Adicionado bloco always: {sensitivity_list}")
                    sequential_found = True
            if not sequential_found:
                python_code.append("        pass")

            has_initial = False
            total_delay = 0
            for stmt in body:
                if stmt['type'] == 'Initial':
                    python_code.append("\n    def run_initial(self):")
                    python_code.append("        # Simulação do bloco initial")
                    for sub_stmt in stmt['statements']:
                        if sub_stmt['type'] == 'Monitor':
                            format_string = sub_stmt['args'][0]['value']
                            # Adicionar %0d como especificador válido
                            specifiers = [part for part in format_string.split() if part in ('%t', '%b', '%d', '%0d')]
                            args = []
                            if len(sub_stmt['args']) > 1:
                                # Assumir que o primeiro especificador numérico é $time
                                if '%t' in format_string or '%0d' in format_string:
                                    args.append("self.time")
                                for arg in sub_stmt['args'][1]['value']:
                                    if arg[0] == 'IDENTIFIER':
                                        args.append(f"self.{arg[1]}.value")
                                    elif arg[0] == 'KEYWORD' and arg[1] == '$time':
                                        args.append("self.time")
                                    else:
                                        args.append(translate_expression([arg]))
                            new_format_string = format_string
                            for i, spec in enumerate(specifiers):
                                if i < len(args):
                                    if spec == '%t' or spec == '%0d':
                                        new_format_string = new_format_string.replace(spec, f'{{{args[i]}}}', 1)
                                    elif spec == '%b':
                                        new_format_string = new_format_string.replace('%b', f'{{{args[i]}:b}}', 1)
                                    elif spec == '%d':
                                        new_format_string = new_format_string.replace('%d', f'{{{args[i]}}}', 1)
                            python_code.append(f"        print(f\"{new_format_string}\")")
                        elif sub_stmt['type'] == 'DelayAssignment':
                            total_delay += sub_stmt['delay']
                            python_code.append(f"        if self.time == {total_delay}:")
                            python_code.append(f"            self.{sub_stmt['lhs']}.set_value({translate_expression(sub_stmt['rhs'])})")
                        elif sub_stmt['type'] == 'Finish':
                            total_delay += sub_stmt['delay']
                            python_code.append(f"        if self.time == {total_delay}:")
                            python_code.append("            return False  # $finish")
                    python_code.append("        return True")
                    has_initial = True
                    break

            python_code.append("\n    def run(self):")
            if has_initial:
                python_code.append("        while self.run_initial():")
                python_code.append("            self.update_combinational()")
                python_code.append("            self.update_sequential()")
                time_step = clock_delay if clock_delay is not None else 1
                python_code.append(f"            self.time += {time_step}  # Passo de tempo baseado no clock")
            else:
                python_code.append("        self.update_combinational()")
                python_code.append("        self.update_sequential()")

            python_code.append("\n# Teste manual")
            python_code.append("if __name__ == \"__main__\":")
            python_code.append(f"    sim = {module_name}()")
            python_code.append("    sim.run()")

    result = "\n".join(python_code)
    print("Código Python gerado:", result)
    return result

def translate_expression(expr):
    print(f"Traduzindo expressão: {expr}")
    result = []
    i = 0
    while i < len(expr):
        token_type, token_value = expr[i]
        
        if token_type == 'OPERATOR' and token_value == '~':
            i += 1
            if i < len(expr) and expr[i][0] == 'IDENTIFIER':
                result.append(f"1 - self.{expr[i][1]}.value")
                i += 1
            else:
                result.append('~')
        elif token_type == 'IDENTIFIER':
            result.append(f"self.{token_value}.value")
            i += 1
        elif token_type == 'NUMBER':
            if "'b" in token_value:
                bits, value = token_value.split("'b")
                result.append(str(int(value, 2)))
            elif "'h" in token_value:
                bits, value = token_value.split("'h")
                result.append(str(int(value, 16)))
            else:
                result.append(token_value)
            i += 1
        elif token_type == 'OPERATOR':
            if token_value == '&&':
                result.append('and')
            elif token_value == '||':
                result.append('or')
            elif token_value == '!':
                result.append('not ')
            elif token_value == 'CONCAT_START':
                i += 1
                if i < len(expr) and expr[i][0] == 'CONCAT':
                    concat_terms = expr[i][1]
                    translated_terms = []
                    for term in concat_terms:
                        if term[0] == 'IDENTIFIER':
                            translated_terms.append(f"self.{term[1]}.value")
                        else:
                            translated_terms.append(translate_expression([term]))
                    i += 1
                    i += 1
                    concat_expr = []
                    for idx, term in enumerate(reversed(translated_terms)):
                        concat_expr.append(f"({term} << {idx})")
                    result.append(" | ".join(concat_expr))
                else:
                    result.append("CONCAT_START")
            else:
                result.append(token_value)
            i += 1
        elif token_type == 'SYMBOL' and token_value == '{':
            concat_terms = []
            i += 1
            while i < len(expr) and expr[i][1] != '}':
                if expr[i][0] == 'IDENTIFIER':
                    concat_terms.append(f"self.{expr[i][1]}.value")
                elif expr[i][0] == 'SYMBOL' and expr[i][1] == ',':
                    i += 1
                    continue
                else:
                    concat_terms.append(translate_expression([expr[i]]))
                i += 1
            i += 1
            concat_expr = []
            for idx, term in enumerate(reversed(concat_terms)):
                concat_expr.append(f"({term} << {idx})")
            result.append(" | ".join(concat_expr))
        elif token_type == 'SYMBOL':
            result.append(token_value)
            i += 1
        elif token_type == 'STRING':
            result.append(f"'{token_value}'")
            i += 1
        elif token_type == 'KEYWORD' and token_value == '$time':
            result.append("self.time")
            i += 1
        else:
            i += 1
    
    translated = ' '.join(result)
    print(f"Expressão traduzida: {translated}")
    return translated

def translate_statement(stmt, indent=0):
    print(f"Traduzindo statement: {stmt}")
    indent_str = "    " * indent
    if stmt['type'] == 'Assignment':
        lhs = stmt['lhs']
        rhs = translate_expression(stmt['rhs'])
        return f"{indent_str}self.{lhs}.set_value({rhs})"
    elif stmt['type'] == 'If':
        condition = translate_expression(stmt['condition'])
        true_code = [translate_statement(s, indent + 1) for s in stmt['true_statements']]
        false_statements = stmt.get('false_statements', [])
        code = [f"{indent_str}if {condition}:"]
        code.extend(true_code)
        if false_statements:
            if len(false_statements) == 1 and false_statements[0]['type'] == 'If':
                # Transforma o próximo If em elif
                next_if = false_statements[0]
                next_condition = translate_expression(next_if['condition'])
                next_true_code = [translate_statement(s, indent + 1) for s in next_if['true_statements']]
                next_false_statements = next_if.get('false_statements', [])
                code.append(f"{indent_str}elif {next_condition}:")
                code.extend(next_true_code)
                if next_false_statements:
                    code.append(f"{indent_str}else:")
                    code.extend([translate_statement(s, indent + 1) for s in next_false_statements])
            else:
                code.append(f"{indent_str}else:")
                code.extend([translate_statement(s, indent + 1) for s in false_statements])
        return "\n".join(code)
    return f"{indent_str}pass  # Declaração não suportada: {stmt['type']}"

]

novo: 

[

    def generate_python(ast):
    print("Iniciando geração de código Python com AST:", ast)
    python_code = []
    python_code.append("class Signal:\n    def __init__(self, value=0, bit_width=None):\n        self.value = value\n        self.bit_width = bit_width\n        if bit_width:\n            self.max_value = (1 << (bit_width[0] - bit_width[1] + 1)) - 1\n        else:\n            self.max_value = None\n        self.prev_value = value  # Para detectar bordas\n\n    def set_value(self, value):\n        self.prev_value = self.value\n        if self.bit_width and self.max_value is not None:\n            self.value = value & self.max_value\n        else:\n            self.value = value\n\n    def __str__(self):\n        if self.value is None:\n            return 'xx'\n        return f'{self.value:0{self.bit_width[0] - self.bit_width[1] + 1}b}' if self.bit_width else f'{self.value:b}'\n\n")

    for node in ast['body']:
        if node['type'] == 'Module':
            module_name = node['name']
            ports = node['ports']
            body = node['body']

            python_code.append(f"class {module_name}:")
            python_code.append("    def __init__(self):")
            print(f"Gerando __init__ para módulo {module_name}")

            for port in ports:
                port_name = port['name']
                bit_width = port.get('bit_width')
                data_type = port.get('data_type', '')
                comment = f"{port['type']}"
                if data_type:
                    comment += f", {data_type}"
                if bit_width:
                    comment += f", [{bit_width[0]}:{bit_width[1]}]"
                python_code.append(f"        self.{port_name} = Signal(bit_width={bit_width})  # {comment}")
                print(f"Adicionado porto: self.{port_name}")

            for stmt in body:
                if stmt['type'] == 'Declaration':
                    var_name = stmt['name']
                    bit_width = stmt.get('bit_width')
                    initial_value = stmt.get('initial_value')
                    value_str = f", value={initial_value}" if initial_value is not None else ""
                    python_code.append(f"        self.{var_name} = Signal(bit_width={bit_width}{value_str})  # {stmt['decl_type']}")
                    print(f"Adicionada declaração: self.{var_name}")

            python_code.append("        self.time = 0  # Simulação de $time")

            python_code.append("\n    def update_combinational(self):")
            combinational_found = False
            for stmt in body:
                if stmt['type'] == 'Assign':
                    lhs = stmt['lhs']
                    rhs = translate_expression(stmt['rhs'])
                    python_code.append(f"        self.{lhs}.set_value({rhs})")
                    print(f"Adicionada atribuição combinacional: self.{lhs}.set_value({rhs})")
                    combinational_found = True
            if not combinational_found:
                python_code.append("        pass")

            python_code.append("\n    def update_sequential(self):")
            sequential_found = False
            clock_delay = None
            for stmt in body:
                if stmt['type'] == 'AlwaysDelay':
                    clock_delay = stmt['delay']
                    python_code.append(f"        # Clock gerado com atraso de {stmt['delay']} unidades")
                    python_code.append(f"        # Simulação simplificada: alterna o sinal")
                    python_code.append(translate_statement(stmt['statement'], indent=2))
                    print(f"Adicionado AlwaysDelay com delay {stmt['delay']}")
                    sequential_found = True
                elif stmt['type'] == 'Always':
                    sensitivity_list = stmt['sensitivity_list']
                    statements = stmt['statements']
                    sensitivity_comment = "        # Sensível a " + ", ".join(
                        f"{s['edge']} de {s['signal']}" if s['edge'] else s['signal'] 
                        for s in sensitivity_list
                    )
                    python_code.append(sensitivity_comment)
                    python_code.append("        # Simulação simplificada: atualiza na borda")
                    conditions = []
                    for s in sensitivity_list:
                        if s['edge'] == 'posedge':
                            signal = s['signal']
                            conditions.append(f"self.{signal}.value and not self.{signal}.prev_value")
                    if conditions:
                        python_code.append(f"        if {' or '.join(conditions)}:  # Borda positiva")
                        for sub_stmt in statements:
                            if sub_stmt['type'] == 'Display':
                                python_code.append(translate_statement(sub_stmt, indent=3))
                            elif sub_stmt['type'] == 'Assignment':
                                python_code.append(translate_statement(sub_stmt, indent=3))
                        for s in sensitivity_list:
                            if s['edge'] == 'posedge':
                                signal = s['signal']
                                python_code.append(f"        self.{signal}.prev_value = self.{signal}.value")
                    else:
                        for sub_stmt in statements:
                            python_code.append(translate_statement(sub_stmt, indent=2))
                    print(f"Adicionado bloco always: {sensitivity_list}")
                    sequential_found = True
            if not sequential_found:
                python_code.append("        pass")

            has_initial = False
            total_delay = 0
            for stmt in body:
                if stmt['type'] == 'Initial':
                    python_code.append("\n    def run_initial(self):")
                    python_code.append("        # Simulação do bloco initial")
                    for sub_stmt in stmt['statements']:
                        if sub_stmt['type'] == 'Monitor':
                            format_string = sub_stmt['args'][0]['value']
                            specifiers = [part for part in format_string.split() if part in ('%t', '%b', '%d', '%0d')]
                            args = []
                            if len(sub_stmt['args']) > 1:
                                if '%t' in format_string or '%0d' in format_string:
                                    args.append("self.time")
                                for arg in sub_stmt['args'][1]['value']:
                                    if arg[0] == 'IDENTIFIER':
                                        args.append(f"self.{arg[1]}.value")
                                    elif arg[0] == 'KEYWORD' and arg[1] == '$time':
                                        args.append("self.time")
                                    else:
                                        args.append(translate_expression([arg]))
                            new_format_string = format_string
                            for i, spec in enumerate(specifiers):
                                if i < len(args):
                                    if spec == '%t' or spec == '%0d':
                                        new_format_string = new_format_string.replace(spec, f'{{{args[i]}}}', 1)
                                    elif spec == '%b':
                                        new_format_string = new_format_string.replace('%b', f'{{{args[i]}:b}}', 1)
                                    elif spec == '%d':
                                        new_format_string = new_format_string.replace('%d', f'{{{args[i]}}}', 1)
                            python_code.append(f"        print(f\"{new_format_string}\")")
                        elif sub_stmt['type'] == 'DelayAssignment':
                            total_delay += sub_stmt['delay']
                            python_code.append(f"        if self.time == {total_delay}:")
                            python_code.append(f"            self.{sub_stmt['lhs']}.set_value({translate_expression(sub_stmt['rhs'])})")
                        elif sub_stmt['type'] == 'Repeat':
                            count = sub_stmt['count']
                            delay = sub_stmt['statement']['delay']
                            initial_delay = total_delay
                            for i in range(count):
                                total_delay += delay
                                python_code.append(f"        if self.time == {initial_delay + (i + 1) * delay}:")
                                python_code.append(f"            self.{sub_stmt['statement']['lhs']}.set_value({translate_expression(sub_stmt['statement']['rhs'])})")
                        elif sub_stmt['type'] == 'Finish':
                            total_delay += sub_stmt['delay']
                            python_code.append(f"        if self.time == {total_delay}:")
                            python_code.append("            print(f'main.v:15: $finish called at {self.time} (1s)')")
                            python_code.append("            return False  # $finish")
                    python_code.append("        return True")
                    has_initial = True
                    break

            python_code.append("\n    def run(self):")
            if has_initial:
                python_code.append("        while self.run_initial():")
                python_code.append("            self.update_combinational()")
                python_code.append("            self.update_sequential()")
                time_step = clock_delay if clock_delay is not None else 1
                python_code.append(f"            self.time += {time_step}  # Passo de tempo baseado no clock")
            else:
                python_code.append("        self.update_combinational()")
                python_code.append("        self.update_sequential()")

            python_code.append("\n# Teste manual")
            python_code.append("if __name__ == \"__main__\":")
            python_code.append(f"    sim = {module_name}()")
            python_code.append("    sim.run()")

    result = "\n".join(python_code)
    print("Código Python gerado:", result)
    return result

def translate_expression(expr):
    print(f"Traduzindo expressão: {expr}")
    if isinstance(expr, list):
        if len(expr) == 1:
            if isinstance(expr[0], dict) and 'type' in expr[0] and expr[0]['type'] == 'Ternary':
                condition = translate_expression(expr[0]['condition'])
                true_val = translate_expression([expr[0]['true']])
                false_val = translate_expression([expr[0]['false']])
                return f"({true_val} if {condition} else {false_val})"
            token_type, token_value = expr[0]
            if token_type == 'IDENTIFIER':
                return f"self.{token_value}.value"
            elif token_type == 'NUMBER':
                if "'b" in token_value:
                    bits, value = token_value.split("'b")
                    return str(int(value, 2))
                elif "'h" in token_value:
                    bits, value = token_value.split("'h")
                    return str(int(value, 16))
                else:
                    return token_value
            elif token_type == 'STRING':
                return f"'{token_value}'"
            elif token_type == 'KEYWORD' and token_value == '$time':
                return "self.time"
        elif len(expr) == 2 and expr[0][0] == 'OPERATOR':
            op = expr[0][1]
            operand = translate_expression([expr[1]])
            if op == '~':
                return f"~{operand}"
            return f"{op}{operand}"
        elif len(expr) == 3:
            left = translate_expression([expr[0]])
            op = expr[1][1]
            right = translate_expression([expr[2]])
            if op == '&&':
                return f"{left} and {right}"
            elif op == '||':
                return f"{left} or {right}"
            elif op == '!':
                return f"not {right}"
            return f"{left} {op} {right}"
        elif expr[0][0] == 'OPERATOR' and expr[0][1] == 'CONCAT_START':
            concat_args = []
            i = 1
            while i < len(expr) and expr[i][0] != 'CONCAT_END':
                if expr[i][0] == 'CONCAT':
                    concat_args.extend([translate_expression([e]) for e in expr[i][1]])
                i += 1
            concat_expr = []
            for idx, term in enumerate(reversed(concat_args)):
                concat_expr.append(f"({term} << {idx})")
            return " | ".join(concat_expr)
        elif len(expr) > 1:
            return " ".join(translate_expression([e]) for e in expr)
    elif isinstance(expr, dict) and 'type' in expr and expr['type'] == 'Ternary':
        condition = translate_expression(expr['condition'])
        true_val = translate_expression([expr['true']])
        false_val = translate_expression([expr['false']])
        return f"({true_val} if {condition} else {false_val})"
    raise ValueError(f"Expressão inválida: {expr}")

def translate_statement(stmt, indent=0):
    print(f"Traduzindo statement: {stmt}")
    indent_str = "    " * indent
    if stmt['type'] == 'Assignment':
        lhs = stmt['lhs']
        rhs = translate_expression(stmt['rhs'])
        return f"{indent_str}self.{lhs}.set_value({rhs})"
    elif stmt['type'] == 'Repeat':
        count = stmt['count']
        inner_stmt = translate_statement(stmt['statement'], indent + 1)
        return f"{indent_str}for _ in range({count}):\n{inner_stmt}"
    elif stmt['type'] == 'If':
        condition = translate_expression(stmt['condition'])
        true_code = [translate_statement(s, indent + 1) for s in stmt['true_statements']]
        false_statements = stmt.get('false_statements', [])
        code = [f"{indent_str}if {condition}:"]
        code.extend(true_code)
        if false_statements:
            if len(false_statements) == 1 and false_statements[0]['type'] == 'If':
                next_if = false_statements[0]
                next_condition = translate_expression(next_if['condition'])
                next_true_code = [translate_statement(s, indent + 1) for s in next_if['true_statements']]
                next_false_statements = next_if.get('false_statements', [])
                code.append(f"{indent_str}elif {next_condition}:")
                code.extend(next_true_code)
                if next_false_statements:
                    code.append(f"{indent_str}else:")
                    code.extend([translate_statement(s, indent + 1) for s in next_false_statements])
            else:
                code.append(f"{indent_str}else:")
                code.extend([translate_statement(s, indent + 1) for s in false_statements])
        return "\n".join(code)
    elif stmt['type'] == 'Monitor':
        format_string = stmt['args'][0]['value']
        args = []
        if len(stmt['args']) > 1:
            for arg in stmt['args'][1]['value']:
                if arg[0] == 'KEYWORD' and arg[1] == '$time':
                    args.append("self.time")
                elif arg[0] == 'IDENTIFIER':
                    args.append(f"self.{arg[1]}")
                else:
                    args.append(translate_expression([arg]))
        if format_string == "%t: %b %b -> %b":
            new_format_string = "{self.time}: {self.rst} {self.cmd} -> {self.out}"
        else:
            specifiers = [part for part in format_string.split() if part in ('%t', '%b', '%d', '%0d')]
            new_format_string = format_string.replace('%t', '{self.time}')
            for i, spec in enumerate(specifiers[1:], 1):
                if i < len(args):
                    if spec == '%b':
                        new_format_string = new_format_string.replace(spec, f'{{{args[i]}}}', 1)
                    elif spec == '%d' or spec == '%0d':
                        new_format_string = new_format_string.replace(spec, f'{{{args[i]}}}', 1)
        return f"{indent_str}print(f\"{new_format_string}\")"
    elif stmt['type'] == 'Display':
        format_string = stmt['args'][0]['value']
        args = []
        if len(stmt['args']) > 1:
            for arg in stmt['args'][1]['value']:
                if arg[0] == 'KEYWORD' and arg[1] == '$time':
                    args.append("self.time")
                elif arg[0] == 'IDENTIFIER':
                    args.append(f"self.{arg[1]}")
                else:
                    args.append(translate_expression([arg]))
        if format_string == "%t: %b %b -> %b":
            new_format_string = "{self.time}: {self.rst} {self.cmd} -> {self.out}"
        else:
            specifiers = [part for part in format_string.split() if part in ('%t', '%b', '%d', '%0d')]
            new_format_string = format_string.replace('%t', '{self.time}')
            for i, spec in enumerate(specifiers[1:], 1):
                if i < len(args):
                    if spec == '%b':
                        new_format_string = new_format_string.replace(spec, f'{{{args[i]}}}', 1)
                    elif spec == '%d' or spec == '%0d':
                        new_format_string = new_format_string.replace(spec, f'{{{args[i]}}}', 1)
        return f"{indent_str}print(f\"{new_format_string}\")"
    elif stmt['type'] == 'DelayAssignment':
        lhs = stmt['lhs']
        rhs = translate_expression(stmt['rhs'])
        return f"{indent_str}self.{lhs}.set_value({rhs})"
    return f"{indent_str}pass  # Declaração não suportada: {stmt['type']}"
]


exemplos dos teste: 

from django.test import TestCase
from rest_framework.test import APIClient
from rest_framework import status

class SyslogPyNewTestCase(TestCase):
    def setUp(self):
        self.client = APIClient()

    def test_cmd_out_register(self):
        """Testa a geração de Python a partir de um Verilog com clock, reset, cmd e out."""
        input_code = (
            "module main;\n"
            "    reg clk=0, rst=1;\n"
            "    reg [1:0] cmd=0, out;\n"
            "    \n"
            "    always #5 clk = ~clk;\n"
            "    \n"
            "    always @(posedge clk or posedge rst) begin\n"
            "        out <= rst ? 0 : cmd;\n"
            "        $display(\"%t: %b %b -> %b\", $time, rst, cmd, out);\n"
            "    end\n"
            "    \n"
            "    initial begin\n"
            "        #10 rst=0;\n"
            "        repeat(3) #10 cmd=cmd+1;\n"
            "        #10 $finish;\n"
            "    end\n"
            "endmodule"
        )
        response = self.client.post('/api/compile-syslog-py/', {'code': input_code}, format='json')
        self.assertEqual(response.status_code, status.HTTP_200_OK, f"Erro na API: {response.json()}")

        data = response.json()
        py_code = data['python']

        expected_py_code = (
            "class Signal:\n"
            "    def __init__(self, value=0, bit_width=None):\n"
            "        self.value = value\n"
            "        self.bit_width = bit_width\n"
            "        if bit_width:\n"
            "            self.max_value = (1 << (bit_width[0] - bit_width[1] + 1)) - 1\n"
            "        else:\n"
            "            self.max_value = None\n"
            "        self.prev_value = value  # Para detectar bordas\n"
            "\n"
            "    def set_value(self, value):\n"
            "        self.prev_value = self.value\n"
            "        if self.bit_width and self.max_value is not None:\n"
            "            self.value = value & self.max_value\n"
            "        else:\n"
            "            self.value = value\n"
            "\n"
            "    def __str__(self):\n"
            "        if self.value is None:\n"
            "            return 'xx'\n"
            "        return f'{self.value:0{self.bit_width[0] - self.bit_width[1] + 1}b}' if self.bit_width else f'{self.value:b}'\n"
            "\n"
            "\n"
            "class main:\n"
            "    def __init__(self):\n"
            "        self.clk = Signal(bit_width=None, value=0)  # reg\n"
            "        self.rst = Signal(bit_width=None, value=1)  # reg\n"
            "        self.cmd = Signal(bit_width=(1, 0), value=0)  # reg\n"
            "        self.out = Signal(bit_width=(1, 0))  # reg\n"
            "        self.time = 0  # Simulação de $time\n"
            "\n"
            "    def update_combinational(self):\n"
            "        pass\n"
            "\n"
            "    def update_sequential(self):\n"
            "        # Clock gerado com atraso de 5 unidades\n"
            "        # Simulação simplificada: alterna o sinal\n"
            "        self.clk.set_value(~self.clk.value)\n"
            "        # Sensível a posedge de clk, posedge de rst\n"
            "        # Simulação simplificada: atualiza na borda\n"
            "        if self.clk.value and not self.clk.prev_value or self.rst.value and not self.rst.prev_value:  # Borda positiva\n"
            "            self.out.set_value((0 if self.rst.value else self.cmd.value))\n"
            "            print(f\"{self.time}: {self.rst} {self.cmd} -> {self.out}\")\n"
            "        self.clk.prev_value = self.clk.value\n"
            "        self.rst.prev_value = self.rst.value\n"
            "\n"
            "    def run_initial(self):\n"
            "        # Simulação do bloco initial\n"
            "        if self.time == 10:\n"
            "            self.rst.set_value(0)\n"
            "        if self.time == 20:\n"
            "            self.cmd.set_value(self.cmd.value + 1)\n"
            "        if self.time == 30:\n"
            "            self.cmd.set_value(self.cmd.value + 1)\n"
            "        if self.time == 40:\n"
            "            self.cmd.set_value(self.cmd.value + 1)\n"
            "        if self.time == 50:\n"
            "            print(f'main.v:15: $finish called at {self.time} (1s)')\n"
            "            return False  # $finish\n"
            "        return True\n"
            "\n"
            "    def run(self):\n"
            "        while self.run_initial():\n"
            "            self.update_combinational()\n"
            "            self.update_sequential()\n"
            "            self.time += 5  # Passo de tempo baseado no clock\n"
            "\n"
            "# Teste manual\n"
            "if __name__ == \"__main__\":\n"
            "    sim = main()\n"
            "    sim.run()"
        )

        self.assertEqual(py_code.strip(), expected_py_code.strip(), "Código Python gerado não corresponde ao esperado.")



from django.test import TestCase
from rest_framework.test import APIClient
from rest_framework import status

class SyslogPyNewTestCase(TestCase):
    def setUp(self):
        self.client = APIClient()

    def test_counter_with_monitor_new(self):
        """Testa a geração de Python a partir de um Verilog com contador, clock e $monitor."""
        input_code = (
            "/* \n"
            " * Do not change Module name \n"
            "*/\n"
            "module main;\n"
            "  reg clk = 0;\n"
            "  reg reset = 1;\n"
            "  reg [1:0] count;  // Contador de 2 bits (0 a 3)\n"
            "\n"
            "  // Gerador de clock\n"
            "  always #5 clk = ~clk;\n"
            "\n"
            "  // Lógica do contador\n"
            "  always @(posedge clk or posedge reset) begin\n"
            "    if (reset) \n"
            "      count <= 2'b00;  // Começa em 0\n"
            "    else if (count == 2'b11) // Se chegar em 3\n"
            "      count <= 2'b00;  // Reinicia\n"
            "    else\n"
            "      count <= count + 1; // Incrementa\n"
            "  end\n"
            "\n"
            "  initial begin\n"
            "    // Monitorar os valores\n"
            "    $monitor(\"Tempo: %t | Count: %d\", $time, count);\n"
            "    \n"
            "    // Reset inicial\n"
            "    #10 reset = 0;\n"
            "    \n"
            "    // Executa até contar até 3 duas vezes\n"
            "    #60 $finish;\n"
            "  end\n"
            "endmodule"
        )
        response = self.client.post('/api/compile-syslog-py/', {'code': input_code}, format='json')
        self.assertEqual(response.status_code, status.HTTP_200_OK, f"Erro na API: {response.json()}")

        data = response.json()
        py_code = data['python']

        expected_py_code = (
            "class Signal:\n"
            "    def __init__(self, value=0, bit_width=None):\n"
            "        self.value = value\n"
            "        self.bit_width = bit_width\n"
            "        if bit_width:\n"
            "            self.max_value = (1 << (bit_width[0] - bit_width[1] + 1)) - 1\n"
            "        self.prev_value = value  # Para detectar bordas\n"
            "\n"
            "    def set_value(self, value):\n"
            "        if self.bit_width:\n"
            "            self.value = value & self.max_value\n"
            "        else:\n"
            "            self.value = value\n"
            "\n"
            "\n"
            "class main:\n"
            "    def __init__(self):\n"
            "        self.clk = Signal(bit_width=None, value=0)  # reg\n"
            "        self.reset = Signal(bit_width=None, value=1)  # reg\n"
            "        self.count = Signal(bit_width=(1, 0))  # reg\n"
            "        self.time = 0  # Simulação de $time\n"
            "\n"
            "    def update_combinational(self):\n"
            "        pass\n"
            "\n"
            "    def update_sequential(self):\n"
            "        # Clock gerado com atraso de 5 unidades\n"
            "        # Simulação simplificada: alterna o sinal\n"
            "        self.clk.set_value(1 - self.clk.value)\n"
            "        # Sensível a posedge de clk, posedge de reset\n"
            "        # Simulação simplificada: atualiza na borda\n"
            "        if self.clk.value and not self.clk.prev_value or self.reset.value and not self.reset.prev_value:  # Borda positiva\n"
            "            if self.reset.value:\n"
            "                self.count.set_value(0)\n"
            "            elif self.count.value == 3:\n"
            "                self.count.set_value(0)\n"
            "            else:\n"
            "                self.count.set_value(self.count.value + 1)\n"
            "        self.clk.prev_value = self.clk.value\n"
            "        self.reset.prev_value = self.reset.value\n"
            "\n"
            "    def run_initial(self):\n"
            "        # Simulação do bloco initial\n"
            "        print(f\"Tempo: {self.time} | Count: {self.count.value}\")\n"
            "        if self.time == 10:\n"
            "            self.reset.set_value(0)\n"
            "        if self.time == 70:\n"
            "            return False  # $finish\n"
            "        return True\n"
            "\n"
            "    def run(self):\n"
            "        while self.run_initial():\n"
            "            self.update_combinational()\n"
            "            self.update_sequential()\n"
            "            self.time += 5  # Passo de tempo baseado no clock\n"
            "\n"
            "# Teste manual\n"
            "if __name__ == \"__main__\":\n"
            "    sim = main()\n"
            "    sim.run()"
        )

        self.assertEqual(py_code.strip(), expected_py_code.strip(), "Código Python gerado não corresponde ao esperado.")
        
    def test_simple_clock_new(self):
        """Testa a geração de Python a partir de um Verilog simples com clock e $finish."""
        input_code = (
            "module main;\n"
            "  reg clk = 0;\n"
            "  always #5 clk = ~clk;\n"
            "  initial begin\n"
            "    #50 $finish;\n"
            "  end\n"
            "endmodule"
        )
        response = self.client.post('/api/compile-syslog-py/', {'code': input_code}, format='json')
        self.assertEqual(response.status_code, status.HTTP_200_OK, f"Erro na API: {response.json()}")

        data = response.json()
        py_code = data['python']

        expected_py_code = (
            "class Signal:\n"
            "    def __init__(self, value=0, bit_width=None):\n"
            "        self.value = value\n"
            "        self.bit_width = bit_width\n"
            "        if bit_width:\n"
            "            self.max_value = (1 << (bit_width[0] - bit_width[1] + 1)) - 1\n"
            "        self.prev_value = value  # Para detectar bordas\n"
            "\n"
            "    def set_value(self, value):\n"
            "        if self.bit_width:\n"
            "            self.value = value & self.max_value\n"
            "        else:\n"
            "            self.value = value\n"
            "\n"
            "\n"
            "class main:\n"
            "    def __init__(self):\n"
            "        self.clk = Signal(bit_width=None, value=0)  # reg\n"
            "        self.time = 0  # Simulação de $time\n"
            "\n"
            "    def update_combinational(self):\n"
            "        pass\n"
            "\n"
            "    def update_sequential(self):\n"
            "        # Clock gerado com atraso de 5 unidades\n"
            "        # Simulação simplificada: alterna o sinal\n"
            "        self.clk.set_value(1 - self.clk.value)\n"
            "\n"
            "    def run_initial(self):\n"
            "        # Simulação do bloco initial\n"
            "        if self.time == 50:\n"
            "            return False  # $finish\n"
            "        return True\n"
            "\n"
            "    def run(self):\n"
            "        while self.run_initial():\n"
            "            self.update_combinational()\n"
            "            self.update_sequential()\n"
            "            self.time += 5  # Passo de tempo baseado no clock\n"
            "\n"
            "# Teste manual\n"
            "if __name__ == \"__main__\":\n"
            "    sim = main()\n"
            "    sim.run()"
        )

        self.assertEqual(py_code.strip(), expected_py_code.strip(), "Código Python gerado não corresponde ao esperado.")